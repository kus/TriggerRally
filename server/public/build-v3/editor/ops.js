// Generated by CoffeeScript 1.7.1
(function() {
  define(['underscore'], function(_) {
    var TWOPI, deepClone;
    TWOPI = Math.PI * 2;
    deepClone = function(obj) {
      return JSON.parse(JSON.stringify(obj));
    };
    return {
      addScenery: function(track, layer, layerIdx, selection) {
        var a, b, i, idx, model, newScenery, newSel, rotZ, scenery, sel, sels, _i, _len;
        scenery = deepClone(track.config.scenery);
        newSel = [];
        newScenery = null;
        sels = (function() {
          var _i, _len, _ref, _results;
          _ref = selection.models;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            model = _ref[_i];
            _results.push(model.get('sel'));
          }
          return _results;
        })();
        sels = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = sels.length; _i < _len; _i++) {
            sel = sels[_i];
            if (sel.type === 'terrain') {
              _results.push(sel);
            }
          }
          return _results;
        })();
        for (i = _i = 0, _len = sels.length; _i < _len; i = ++_i) {
          sel = sels[i];
          rotZ = sels.length === 1 ? Math.random() * TWOPI : (i === 0 ? (a = sel.object.pos, b = sels[i + 1].object.pos) : (a = sels[i - 1].object.pos, b = sel.object.pos), Math.atan2(b[1] - a[1], b[0] - a[0]));
          newScenery = {
            scale: 1,
            rot: [0, 0, rotZ],
            pos: sel.object.pos
          };
          if (scenery[layer] == null) {
            scenery[layer] = {
              add: []
            };
          }
          idx = scenery[layer].add.length;
          scenery[layer].add.push(newScenery);
          newSel.push({
            sel: {
              type: 'scenery',
              distance: sel.distance,
              layer: layer,
              idx: idx,
              object: newScenery
            }
          });
        }
        track.config.scenery = scenery;
        return selection.reset(newSel);
      },
      copy: function(track, selection) {
        var checkpoints, doneCheckpoint, idx, newCp, newObj, newPos, otherCp, scenery, sel, selCp, selModel, _i, _len, _ref;
        doneCheckpoint = false;
        scenery = deepClone(track.config.scenery);
        _ref = selection.models;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          selModel = _ref[_i];
          sel = selModel.get('sel');
          switch (sel.type) {
            case 'checkpoint':
              if (doneCheckpoint) {
                continue;
              }
              doneCheckpoint = true;
              checkpoints = track.config.course.checkpoints;
              sel = selection.first().get('sel');
              idx = sel.idx;
              selCp = checkpoints.at(idx);
              if (idx < checkpoints.length - 1) {
                otherCp = checkpoints.at(idx + 1);
                newPos = [(selCp.pos[0] + otherCp.pos[0]) * 0.5, (selCp.pos[1] + otherCp.pos[1]) * 0.5, (selCp.pos[2] + otherCp.pos[2]) * 0.5];
              } else {
                otherCp = checkpoints.at(idx - 1);
                newPos = [selCp.pos[0] * 2 - otherCp.pos[0], selCp.pos[1] * 2 - otherCp.pos[1], selCp.pos[2] * 2 - otherCp.pos[2]];
              }
              newCp = selCp.clone();
              newCp.pos = newPos;
              selection.reset();
              checkpoints.add(newCp, {
                at: idx + 1
              });
              break;
            case 'scenery':
              newObj = deepClone(track.config.scenery[sel.layer].add[sel.idx]);
              newObj.pos[2] += 5 + 10 * Math.random();
              scenery[sel.layer].add.push(newObj);
          }
        }
        track.config.scenery = scenery;
      },
      "delete": function(track, selection) {
        var checkpoints, checkpointsToRemove, layer, name, scenery, sceneryToRemove, sel, selModel, _i, _len, _ref;
        checkpoints = track.config.course.checkpoints;
        scenery = deepClone(track.config.scenery);
        checkpointsToRemove = [];
        sceneryToRemove = [];
        _ref = selection.models;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          selModel = _ref[_i];
          sel = selModel.get('sel');
          switch (sel.type) {
            case 'checkpoint':
              if (sel.type === 'checkpoint' && checkpoints.length - checkpointsToRemove.length >= 2) {
                checkpointsToRemove.push(sel.object);
              }
              break;
            case 'scenery':
              sceneryToRemove.push(scenery[sel.layer].add[sel.idx]);
          }
        }
        selection.reset();
        checkpoints.remove(checkpointsToRemove);
        for (name in scenery) {
          layer = scenery[name];
          layer.add = _.difference(layer.add, sceneryToRemove);
        }
        track.config.scenery = scenery;
      }
    };
  });

}).call(this);
