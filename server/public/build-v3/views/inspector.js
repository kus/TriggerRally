// Generated by CoffeeScript 1.7.1

/*
 * Copyright (C) 2012 jareiko / http://www.jareiko.net/
 */

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['editor/ops', 'views/view', 'views/tracklist', 'views/user', 'models/index'], function(Ops, View, TrackListView, UserView, models) {
    var InspectorView, deepClone, manipulate;
    deepClone = function(obj) {
      return JSON.parse(JSON.stringify(obj));
    };
    manipulate = function(model, attrib, fn) {
      var obj;
      fn(obj = deepClone(model.get(attrib)));
      return model.set(attrib, obj);
    };
    return InspectorView = (function(_super) {
      __extends(InspectorView, _super);

      function InspectorView($el, app, selection) {
        this.app = app;
        this.selection = selection;
        InspectorView.__super__.constructor.call(this, {
          el: $el
        });
      }

      InspectorView.prototype.destroy = function() {
        var _ref;
        return (_ref = this.userView) != null ? _ref.destroy() : void 0;
      };

      InspectorView.prototype.afterRender = function() {
        var $, $cmdClearRuns, $cmdCopyTrack, $cmdDeleteTrack, $cmdPublishTrack, $flagPreventCopy, $flagSnap, $inspector, $inspectorAttribs, app, attrib, bindSlider, checkpointSliderSet, cmdAdd, cmdClearRuns, cmdCopy, cmdCopyTrack, cmdDelete, cmdDeleteTrack, cmdPublishTrack, enableItem, onChange, onChangeEnv, root, sceneryType, selDispHardness, selDispRadius, selDispStrength, selScale, selSurfHardness, selSurfRadius, selSurfStrength, selTitle, selType, selection, trackListView, updateItemsEnabled, updateName, updateSnap, updateTrackListView, updateUser;
        app = this.app;
        selection = this.selection;
        $ = this.$.bind(this);
        $inspector = this.$el;
        $inspectorAttribs = $inspector.find('.attrib');
        attrib = function(selector) {
          var $el;
          $el = $inspector.find(selector);
          return {
            $root: $el,
            $content: $el.find('.content')
          };
        };
        selType = attrib('#sel-type');
        selTitle = attrib('#title');
        selScale = attrib('#scale');
        selDispRadius = attrib('#disp-radius');
        selDispHardness = attrib('#disp-hardness');
        selDispStrength = attrib('#disp-strength');
        selSurfRadius = attrib('#surf-radius');
        selSurfHardness = attrib('#surf-hardness');
        selSurfStrength = attrib('#surf-strength');
        sceneryType = attrib('#scenery-type');
        cmdAdd = attrib('#cmd-add');
        cmdCopy = attrib('#cmd-copy');
        cmdDelete = attrib('#cmd-delete');
        cmdCopyTrack = attrib('#cmd-copy-track');
        cmdPublishTrack = attrib('#cmd-publish-track');
        cmdClearRuns = attrib('#cmd-clear-runs');
        cmdDeleteTrack = attrib('#cmd-delete-track');
        $cmdCopyTrack = $inspector.find('#cmd-copy-track');
        $cmdPublishTrack = $inspector.find('#cmd-publish-track');
        $cmdClearRuns = $inspector.find('#cmd-clear-runs');
        $cmdDeleteTrack = $inspector.find('#cmd-delete-track');
        $flagPreventCopy = $inspector.find('#flag-prevent-copy input');
        $flagSnap = $inspector.find('#flag-snap input');
        root = app.root;
        trackListView = null;
        (updateTrackListView = function() {
          if (trackListView != null) {
            trackListView.destroy();
          }
          trackListView = root.user && new TrackListView({
            collection: root.user.tracks,
            root: root
          });
          if (trackListView != null) {
            return $('#track-list').append(trackListView.el);
          }
        })();
        this.listenTo(root, 'change:user', updateTrackListView);
        this.userView = null;
        (updateUser = (function(_this) {
          return function() {
            var _ref, _ref1, _ref2;
            if (((_ref = root.track) != null ? _ref.user : void 0) === ((_ref1 = _this.userView) != null ? _ref1.model : void 0)) {
              return;
            }
            if ((_ref2 = _this.userView) != null) {
              _ref2.destroy();
            }
            if (root.track.user != null) {
              _this.userView = new UserView({
                model: root.track.user
              });
              return $('#user-track-owner .content').append(_this.userView.el);
            }
          };
        })(this))();
        this.listenTo(root, 'change:track.user', updateUser);
        enableItem = function($button, enabled) {
          return $button.prop('disabled', !enabled);
        };
        (updateItemsEnabled = function() {
          var editable, isOwnTrack, published, _ref;
          isOwnTrack = ((_ref = root.track) != null ? _ref.user : void 0) === root.user;
          published = isOwnTrack && root.track.published;
          editable = isOwnTrack && !published;
          enableItem(selTitle.$content, editable);
          enableItem(cmdCopyTrack.$content, isOwnTrack || (root.track != null) && !root.track.prevent_copy);
          enableItem(cmdPublishTrack.$content, editable);
          enableItem(cmdClearRuns.$content, editable);
          enableItem(cmdDeleteTrack.$content, editable);
          $("#track-ownership-warning").toggleClass('hidden', isOwnTrack);
          $("#copy-login-prompt").toggleClass('hidden', !!root.user);
          return $("#track-published-warning").toggleClass('hidden', !(isOwnTrack && published));
        })();
        this.listenTo(root, 'change:track.', updateItemsEnabled);
        this.listenTo(root, 'change:user', updateItemsEnabled);
        (onChangeEnv = function() {
          var idx, layer, _i, _len, _ref, _ref1, _ref2, _ref3, _results;
          if (!((_ref = root.track) != null ? (_ref1 = _ref.env) != null ? (_ref2 = _ref1.scenery) != null ? _ref2.layers : void 0 : void 0 : void 0)) {
            return;
          }
          sceneryType.$content.empty();
          _ref3 = root.track.env.scenery.layers;
          _results = [];
          for (idx = _i = 0, _len = _ref3.length; _i < _len; idx = ++_i) {
            layer = _ref3[idx];
            _results.push(sceneryType.$content.append(new Option(layer.id, idx)));
          }
          return _results;
        })();
        this.listenTo(root, 'change:track.env', onChangeEnv);
        (updateName = function() {
          if (root.track == null) {
            return;
          }
          if (selTitle.$content.val() === root.track.name) {
            return;
          }
          return selTitle.$content.val(root.track.name);
        })();
        this.listenTo(root, 'change:track.name', updateName);
        selTitle.$content.on('input', function() {
          return root.track.name = selTitle.$content.val();
        });
        bindSlider = function(type, slider, eachSel) {
          var $content;
          $content = slider.$content;
          return $content.change(function() {
            var sel, selModel, val, _i, _len, _ref, _results;
            val = parseFloat($content.val());
            _ref = selection.models;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              selModel = _ref[_i];
              sel = selModel.get('sel');
              if (sel.type === type) {
                _results.push(eachSel(sel, val));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          });
        };
        bindSlider('checkpoint', selDispRadius, function(sel, val) {
          return manipulate(sel.object, 'disp', function(o) {
            return o.radius = val;
          });
        });
        bindSlider('checkpoint', selDispHardness, function(sel, val) {
          return manipulate(sel.object, 'disp', function(o) {
            return o.hardness = val;
          });
        });
        bindSlider('checkpoint', selDispStrength, function(sel, val) {
          return manipulate(sel.object, 'disp', function(o) {
            return o.strength = val;
          });
        });
        bindSlider('checkpoint', selSurfRadius, function(sel, val) {
          return manipulate(sel.object, 'surf', function(o) {
            return o.radius = val;
          });
        });
        bindSlider('checkpoint', selSurfHardness, function(sel, val) {
          return manipulate(sel.object, 'surf', function(o) {
            return o.hardness = val;
          });
        });
        bindSlider('checkpoint', selSurfStrength, function(sel, val) {
          return manipulate(sel.object, 'surf', function(o) {
            return o.strength = val;
          });
        });
        bindSlider('scenery', selScale, function(sel, val) {
          var scenery;
          scenery = deepClone(root.track.config.scenery);
          scenery[sel.layer].add[sel.idx].scale = Math.exp(val);
          return root.track.config.scenery = scenery;
        });
        cmdAdd.$content.click(function() {
          var $sceneryType, layer, layerIdx;
          $sceneryType = sceneryType.$content.find(":selected");
          layerIdx = $sceneryType.val();
          layer = $sceneryType.text();
          return Ops.addScenery(root.track, layer, layerIdx, selection);
        });
        cmdCopy.$content.click(function() {
          return Ops.copy(root.track, selection);
        });
        cmdDelete.$content.click(function() {
          return Ops["delete"](root.track, selection);
        });
        cmdCopyTrack.$content.click(function() {
          var newTrack;
          newTrack = new models.Track({
            parent: root.track
          });
          return newTrack.save(null, {
            success: function() {
              root.user.tracks.add(newTrack);
              return Backbone.trigger("app:settrack", newTrack);
            },
            error: function(model, xhr) {
              var data, msg, _ref;
              data = JSON.parse(xhr.responseText);
              msg = (_ref = data != null ? data.error : void 0) != null ? _ref : xhr.statusText;
              return Backbone.trigger("app:status", "Copy failed: " + msg + " (" + xhr.status + ")");
            }
          });
        });
        cmdDeleteTrack.$content.click(function() {
          if (!window.confirm("Are you sure you want to DELETE this track? This can't be undone!")) {
            return;
          }
          return root.track.destroy({
            success: function() {
              return Backbone.history.navigate("/track/v3-base-1/edit", {
                trigger: true
              });
            },
            error: function(model, xhr) {
              return Backbone.trigger("app:status", "Delete failed: " + xhr.statusText + " (" + xhr.status + ")");
            }
          });
        });
        cmdPublishTrack.$content.click(function() {
          if (!window.confirm("Publishing a track will lock it and allow players to start competing for top times. Are you sure?")) {
            return;
          }
          return root.track.save({
            published: true
          });
        });
        (updateSnap = (function(_this) {
          return function() {
            return _this.snapToGround = $flagSnap[0].checked;
          };
        })(this))();
        $flagSnap.on('change', updateSnap);
        checkpointSliderSet = function(slider, val) {
          slider.$content.val(val);
          return slider.$root.addClass('visible');
        };
        (onChange = function() {
          var sel, selModel, _i, _len, _ref;
          $inspectorAttribs.removeClass('visible');
          selType.$content.text((function() {
            switch (selection.length) {
              case 0:
                return 'none';
              case 1:
                sel = selection.first().get('sel');
                if (sel.type === 'scenery') {
                  return sel.layer;
                } else {
                  return sel.type;
                }
                break;
              default:
                return '[multiple]';
            }
          })());
          _ref = selection.models;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            selModel = _ref[_i];
            sel = selModel.get('sel');
            switch (sel.type) {
              case 'checkpoint':
                checkpointSliderSet(selDispRadius, sel.object.disp.radius);
                checkpointSliderSet(selDispHardness, sel.object.disp.hardness);
                checkpointSliderSet(selDispStrength, sel.object.disp.strength);
                checkpointSliderSet(selSurfRadius, sel.object.surf.radius);
                checkpointSliderSet(selSurfHardness, sel.object.surf.hardness);
                checkpointSliderSet(selSurfStrength, sel.object.surf.strength);
                cmdDelete.$root.addClass('visible');
                cmdCopy.$root.addClass('visible');
                break;
              case 'scenery':
                selScale.$content.val(Math.log(sel.object.scale));
                selScale.$root.addClass('visible');
                cmdDelete.$root.addClass('visible');
                cmdCopy.$root.addClass('visible');
                break;
              case 'terrain':
                sceneryType.$root.addClass('visible');
                cmdAdd.$root.addClass('visible');
            }
          }
        })();
        selection.on('add', onChange);
        selection.on('remove', onChange);
        selection.on('reset', onChange);
      };

      return InspectorView;

    })(View);
  });

}).call(this);
