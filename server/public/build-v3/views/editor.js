// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'backbone-full', 'THREE', 'util/util', 'util/util2', 'client/misc', 'client/editor_camera', 'client/car', 'models/index', 'views/inspector', 'views/view', 'jade!templates/editor'], function(_, Backbone, THREE, util, util2, clientMisc, EditorCameraControl, clientCar, models, InspectorView, View, template) {
    var EditorView, KEYCODE, MB, Sel, Selection, TWOPI, Vec2, Vec3, Vec3FromArray, deepClone, tmpVec3, tmpVec3b;
    MB = util2.MB;
    KEYCODE = util.KEYCODE, Vec3FromArray = util.Vec3FromArray;
    Vec2 = THREE.Vector2;
    Vec3 = THREE.Vector3;
    TWOPI = Math.PI * 2;
    tmpVec3 = new THREE.Vector3;
    tmpVec3b = new THREE.Vector3;
    deepClone = function(obj) {
      return JSON.parse(JSON.stringify(obj));
    };
    Sel = Backbone.Model.extend({});
    Selection = Backbone.Collection.extend({
      model: Sel,
      contains: function(sel) {
        return this.some(function(element) {
          return element.get('sel').object === sel.object;
        });
      }
    });
    return EditorView = (function(_super) {
      __extends(EditorView, _super);

      EditorView.prototype.template = template;

      function EditorView(app, client) {
        this.app = app;
        this.client = client;
        EditorView.__super__.constructor.call(this);
      }

      EditorView.prototype.afterRender = function() {
        var $, addSelection, app, buttons, camControl, client, cursor, cursorMesh, doSave, editorObjects, findObject, handleSelAdd, handleSelRemove, hasMoved, lastTime, mockVehicle, mouseX, mouseY, objSpinVel, onChangeStartPosition, onChangeTrackId, onChangeTrackName, renderCar, requestId, root, scroll, selection, startPos, updateCar, updateCursor;
        app = this.app;
        client = this.client;
        root = this.app.root;
        $ = this.$.bind(this);
        this.objs = [];
        client.camera.idealFov = 75;
        client.camera.useQuaternion = false;
        client.updateCamera();
        camControl = new EditorCameraControl(client.camera);
        selection = new Selection();
        this.editorObjects = editorObjects = new THREE.Object3D;
        client.scene.add(editorObjects);
        startPos = new THREE.Object3D();
        editorObjects.add(startPos);
        this.objs.push(client.addEditorCheckpoints(editorObjects));
        doSave = _.debounce(function() {
          var result;
          if (root.user !== root.track.user || root.track.published) {
            return Backbone.trigger('app:status', 'Read only');
          }
          Backbone.trigger('app:status', 'Saving...');
          result = root.track.save(null, {
            success: function(model, response, options) {
              return Backbone.trigger('app:status', 'OK');
            },
            error: function(model, xhr, options) {
              return Backbone.trigger('app:status', "ERROR: " + xhr.statusText + " (" + xhr.status + ")");
            }
          });
          if (!result) {
            return Backbone.trigger('app:status', 'ERROR: save failed');
          }
        }, 1000);
        this.listenTo(root, 'all', function(event) {
          var options;
          options = arguments[arguments.length - 1];
          if (!event.startsWith('change:track')) {
            return;
          }
          if (options != null ? options.dontSave : void 0) {
            return Backbone.trigger('app:status', 'OK');
          } else {
            Backbone.trigger('app:status', 'Changed');
            return doSave();
          }
        });
        (onChangeTrackId = function() {
          var startposition;
          if (!root.track) {
            return;
          }
          selection.reset();
          startposition = root.track.config.course.startposition;
          return camControl.autoTo(startposition.pos, startposition.rot);
        })();
        this.listenTo(root, 'change:track.id', onChangeTrackId);
        (onChangeTrackName = function() {
          if (!root.track) {
            return;
          }
          return document.title = "" + root.track.name + " - Trigger Rally";
        })();
        this.listenTo(root, 'change:track.name', function() {
          return onChangeTrackName;
        });
        (onChangeStartPosition = function() {
          var startposition, _ref, _ref1, _ref2, _ref3;
          startposition = (_ref = root.track) != null ? (_ref1 = _ref.config) != null ? _ref1.course.startposition : void 0 : void 0;
          if (!startposition) {
            return;
          }
          (_ref2 = startPos.position).set.apply(_ref2, startposition.pos);
          return (_ref3 = startPos.rotation).set.apply(_ref3, startposition.rot);
        })();
        this.listenTo(root, 'change:track.config.course.startposition.', onChangeStartPosition);
        mockVehicle = {
          cfg: null,
          body: {
            interp: {
              pos: new Vec3(0, 0, 0),
              ori: (new THREE.Quaternion(1, 1, 1, 1)).normalize()
            }
          }
        };
        renderCar = null;
        (updateCar = (function(_this) {
          return function() {
            var carId, carModel, _ref;
            carId = (_ref = root.getCarId()) != null ? _ref : 'ArbusuG';
            carModel = models.Car.findOrCreate(carId);
            return carModel.fetch({
              success: function() {
                mockVehicle.cfg = carModel.config;
                if (renderCar != null) {
                  renderCar.destroy();
                }
                renderCar = new clientCar.RenderCar(startPos, mockVehicle, null);
                return renderCar.update();
              }
            });
          };
        })(this))();
        this.listenTo(root, 'change:user', updateCar);
        this.listenTo(root, 'change:user.products', updateCar);
        this.listenTo(root, 'change:prefs.car', updateCar);
        this.inspectorView = new InspectorView(this.$('#editor-inspector'), app, selection);
        this.inspectorView.render();
        _.delay(function() {
          return $('#editor-helpbox-wrapper').removeClass('visible');
        }, 1000);
        $('#editor-helpbox-wrapper .close-tab').click(function() {
          return $('#editor-helpbox-wrapper').toggleClass('visible');
        });
        requestId = 0;
        objSpinVel = 0;
        lastTime = 0;
        this.update = function(delta) {
          var keyDown, obj, rot, scenery, sel, selModel, terrainHeight, _i, _len, _ref, _results;
          terrainHeight = 0;
          if (client.track != null) {
            terrainHeight = (client.track.terrain.getContactRayZ(camControl.pos.x, camControl.pos.y)).surfacePos.z;
          }
          keyDown = client.keyDown;
          camControl.update(delta, keyDown, terrainHeight);
          if (keyDown[188]) {
            objSpinVel += 5 * delta;
          } else if (keyDown[190]) {
            objSpinVel -= 5 * delta;
          } else {
            objSpinVel = 0;
          }
          if (objSpinVel !== 0) {
            _ref = selection.models;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              selModel = _ref[_i];
              sel = selModel.get('sel');
              if (sel.object.rot == null) {
                continue;
              }
              rot = deepClone(sel.object.rot);
              rot[2] += objSpinVel * delta;
              rot[2] -= Math.floor(rot[2] / TWOPI) * TWOPI;
              switch (sel.type) {
                case 'scenery':
                  scenery = deepClone(root.track.config.scenery);
                  obj = scenery[sel.layer].add[sel.idx];
                  obj.rot = rot;
                  root.track.config.scenery = scenery;
                  _results.push(sel.object = obj);
                  break;
                default:
                  _results.push(sel.object.rot = rot);
              }
            }
            return _results;
          }
        };
        addSelection = function(sel) {
          return selection.add({
            sel: sel
          });
        };
        handleSelAdd = function(selModel) {
          var pos, radius, sel;
          sel = selModel.get('sel');
          sel.mesh = clientMisc.selectionMesh();
          pos = sel.object.pos;
          radius = 2;
          switch (sel.type) {
            case 'checkpoint':
              radius = 4;
          }
          sel.mesh.scale.multiplyScalar(radius);
          sel.mesh.position.set(pos[0], pos[1], pos[2]);
          return editorObjects.add(sel.mesh);
        };
        handleSelRemove = function(selModel) {
          var mesh;
          mesh = selModel.get('sel').mesh;
          return editorObjects.remove(mesh);
        };
        selection.on('add', handleSelAdd);
        selection.on('remove', handleSelRemove);
        selection.on('reset', function(collection, options) {
          var selModel, _i, _j, _len, _len1, _ref, _ref1, _results;
          _ref = options.previousModels;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            selModel = _ref[_i];
            handleSelRemove(selModel);
          }
          _ref1 = selection.models;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            selModel = _ref1[_j];
            _results.push(handleSelAdd(selModel));
          }
          return _results;
        });
        mouseX = 0;
        mouseY = 0;
        cursor = null;
        cursorMesh = clientMisc.selectionMesh();
        editorObjects.add(cursorMesh);
        buttons = 0;
        hasMoved = false;
        findObject = function(mouseX, mouseY) {
          var isect, obj, _i, _len;
          isect = client.findObject(mouseX, mouseY);
          for (_i = 0, _len = isect.length; _i < _len; _i++) {
            obj = isect[_i];
            if (obj.type === 'terrain') {
              obj.distance += 10;
            }
          }
          isect.sort(function(a, b) {
            return a.distance > b.distance;
          });
          return isect[0];
        };
        updateCursor = function(newCursor) {
          cursor = newCursor;
          if (cursor != null) {
            Vec3.prototype.set.apply(cursorMesh.position, cursor.object.pos);
          }
        };
        this.onMouseDown = function(event) {
          buttons |= 1 << event.button;
          hasMoved = false;
          event.preventDefault();
          return false;
        };
        this.onMouseUp = function(event) {
          buttons &= ~(1 << event.button);
          if (event.button === 0 && !hasMoved) {
            if (!event.shiftKey) {
              selection.reset();
            }
            if (cursor) {
              if (!(root.user !== root.track.user || root.track.published)) {
                if (!selection.contains(cursor)) {
                  addSelection(cursor);
                }
              } else {
                Backbone.trigger('app:status', 'Read only');
              }
            }
          }
        };
        this.onMouseOut = function(event) {
          return buttons = 0;
        };
        this.onMouseMove = function(event) {
          var angX, angZ, contact, cursorPos, motionX, motionY, obj, planeHit, pos, relMotion, rot, rotateMode, scenery, sel, selModel, tmp, viewRay, _i, _len, _ref;
          hasMoved = true;
          motionX = event.offsetX - mouseX;
          motionY = event.offsetY - mouseY;
          angX = motionY * 0.01;
          angZ = motionX * 0.01;
          mouseX = event.offsetX;
          mouseY = event.offsetY;
          if (!(buttons & (MB.LEFT | MB.MIDDLE) && cursor)) {
            updateCursor(findObject(mouseX, mouseY));
          } else {
            rotateMode = (event.altKey && buttons & MB.LEFT) || buttons & MB.MIDDLE;
            viewRay = client.viewRay(mouseX, mouseY);
            cursorPos = cursorMesh.position;
            planeHit = event.shiftKey ? util2.intersectZLine(viewRay, cursorPos) : util2.intersectZPlane(viewRay, cursorPos);
            if (!planeHit) {
              return;
            }
            relMotion = planeHit.pos.clone().subSelf(cursorPos);
            if (selection.contains(cursor)) {
              cursorPos.copy(planeHit.pos);
              _ref = selection.models;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                selModel = _ref[_i];
                sel = selModel.get('sel');
                if (sel.type === 'terrain') {
                  continue;
                }
                if (rotateMode) {
                  rot = deepClone(sel.object.rot);
                  rot[2] += angZ;
                  rot[2] -= Math.floor(rot[2] / TWOPI) * TWOPI;
                  switch (sel.type) {
                    case 'scenery':
                      scenery = deepClone(root.track.config.scenery);
                      obj = scenery[sel.layer].add[sel.idx];
                      obj.rot = rot;
                      root.track.config.scenery = scenery;
                      if (cursor.object === sel.object) {
                        cursor.object = obj;
                      }
                      sel.object = obj;
                      break;
                    default:
                      sel.object.rot = rot;
                  }
                } else {
                  pos = deepClone(sel.object.pos);
                  pos[0] += relMotion.x;
                  pos[1] += relMotion.y;
                  pos[2] += relMotion.z;
                  if (sel.type !== 'checkpoint') {
                    if (this.inspectorView.snapToGround) {
                      tmp = new Vec3(pos[0], pos[1], -Infinity);
                      contact = client.track.terrain.getContact(tmp);
                      pos[2] = contact.surfacePos.z;
                      if (sel.type === 'startpos') {
                        pos[2] += 1;
                      }
                    }
                  }
                  switch (sel.type) {
                    case 'scenery':
                      scenery = deepClone(root.track.config.scenery);
                      obj = scenery[sel.layer].add[sel.idx];
                      obj.pos = pos;
                      root.track.config.scenery = scenery;
                      if (cursor.object === sel.object) {
                        cursor.object = obj;
                      }
                      sel.object = obj;
                      break;
                    default:
                      sel.object.pos = pos;
                  }
                  sel.mesh.position.set(pos[0], pos[1], pos[2]);
                }
              }
            } else {
              if (rotateMode) {
                camControl.rotate(cursorPos, angX, angZ);
              } else {
                relMotion.multiplyScalar(-1);
                camControl.translate(relMotion);
              }
            }
          }
        };
        scroll = function(scrollY, event) {
          var vec;
          if (!cursor) {
            return;
          }
          vec = camControl.pos.clone().subSelf(cursorMesh.position);
          vec.multiplyScalar(Math.exp(scrollY * -0.002) - 1);
          camControl.translate(vec);
          event.preventDefault();
        };
        return this.onMouseWheel = function(event) {
          var deltaY, origEvent, _ref;
          origEvent = event.originalEvent;
          deltaY = (_ref = origEvent.wheelDeltaY) != null ? _ref : origEvent.deltaY;
          return scroll(deltaY, event);
        };
      };

      EditorView.prototype.destroy = function() {
        this.inspectorView.destroy();
        this.client.scene.remove(this.editorObjects);
        return this.client.destroyObjects(this.objs);
      };

      return EditorView;

    })(View);
  });

}).call(this);
