// Generated by CoffeeScript 1.7.1

/*
 * Copyright (C) 2012 jareiko / http://www.jareiko.net/
 */

(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define([], function() {
    var exports;
    exports = {};
    exports.Hash2D = (function() {
      function Hash2D(gridSize) {
        this.gridSize = gridSize;
        this.tiles = {};
      }

      Hash2D.prototype.hasTile = function(tX, tY) {
        var key;
        key = tX + ',' + tY;
        return __indexOf.call(this.tiles, key) >= 0;
      };

      Hash2D.prototype.getTile = function(tX, tY) {
        var key;
        key = tX + ',' + tY;
        return this.tiles[key];
      };

      Hash2D.prototype.setTile = function(tX, tY, tile) {
        var key;
        key = tX + ',' + tY;
        return this.tiles[key] = tile;
      };

      Hash2D.prototype.addObject = function(x, y, object) {
        var key, tX, tY, tile;
        tX = Math.floor(x / this.gridSize);
        tY = Math.floor(y / this.gridSize);
        key = tX + ',' + tY;
        tile = this.tiles[key] || (this.tiles[key] = []);
        tile.push(object);
      };

      Hash2D.prototype.getObjects = function(minX, minY, maxX, maxY) {
        var key, tMaxX, tMaxY, tMinX, tMinY, tX, tY, tile, tiles, _i, _j;
        tMinX = Math.floor(minX / this.gridSize);
        tMaxX = Math.ceil(maxX / this.gridSize);
        tMinY = Math.floor(minY / this.gridSize);
        tMaxY = Math.ceil(maxY / this.gridSize);
        tiles = [];
        for (tY = _i = tMinY; tMinY <= tMaxY ? _i < tMaxY : _i > tMaxY; tY = tMinY <= tMaxY ? ++_i : --_i) {
          for (tX = _j = tMinX; tMinX <= tMaxX ? _j < tMaxX : _j > tMaxX; tX = tMinX <= tMaxX ? ++_j : --_j) {
            key = tX + ',' + tY;
            tile = this.tiles[key];
            if (tile != null) {
              tiles.push(tile);
            }
          }
        }
        return [].concat.apply([], tiles);
      };

      return Hash2D;

    })();
    exports.IndirectHash2D = (function(_super) {
      __extends(IndirectHash2D, _super);

      function IndirectHash2D(gridSize) {
        IndirectHash2D.__super__.constructor.call(this, gridSize);
        this.objects = [];
        this.nextId = 0;
      }

      IndirectHash2D.prototype.addCircle = function(x, y, radius, object) {
        var key, tCenterX, tCenterY, tMaxX, tMaxY, tMinX, tMinY, tRad, tX, tY, tile, _i, _j;
        tCenterX = x / this.gridSize;
        tCenterY = y / this.gridSize;
        tRad = radius / this.gridSize;
        tMinX = Math.floor(tCenterX - tRad);
        tMaxX = Math.ceil(tCenterX + tRad);
        tMinY = Math.floor(tCenterY - tRad);
        tMaxY = Math.ceil(tCenterY + tRad);
        for (tY = _i = tMinY; tMinY <= tMaxY ? _i < tMaxY : _i > tMaxY; tY = tMinY <= tMaxY ? ++_i : --_i) {
          for (tX = _j = tMinX; tMinX <= tMaxX ? _j < tMaxX : _j > tMaxX; tX = tMinX <= tMaxX ? ++_j : --_j) {
            key = tX + ',' + tY;
            tile = this.tiles[key] || (this.tiles[key] = []);
            tile.push(this.nextId);
          }
        }
        this.objects[this.nextId++] = object;
      };

      IndirectHash2D.prototype.getObjects = function(minX, minY, maxX, maxY) {
        var id, idSet, ids, _i, _len;
        ids = IndirectHash2D.__super__.getObjects.call(this, minX, minY, maxX, maxY);
        idSet = [];
        for (_i = 0, _len = ids.length; _i < _len; _i++) {
          id = ids[_i];
          idSet[id] = true;
        }
        return (function() {
          var _results;
          _results = [];
          for (id in idSet) {
            _results.push(this.objects[id]);
          }
          return _results;
        }).call(this);
      };

      return IndirectHash2D;

    })(exports.Hash2D);
    return exports;
  });

}).call(this);
