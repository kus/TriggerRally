// Generated by CoffeeScript 1.7.1
(function() {
  var moduleDef,
    __slice = [].slice;

  moduleDef = function(require, exports, module) {
    var LockedSet, async, _, _callAll, _coerceToNode, _getUniqueId, _pluck, _walk, _walkIn, _walkOut;
    _ = require('underscore');
    async = require("async");
    _getUniqueId = (function() {
      var nextId;
      nextId = 0;
      return function() {
        return ++nextId;
      };
    })();
    _pluck = function(arr, property) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        x = arr[_i];
        _results.push(x[property]);
      }
      return _results;
    };
    _callAll = function(arr) {
      var x, _i, _len;
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        x = arr[_i];
        x();
      }
    };
    exports.wrapSync = function(fn) {
      return function() {
        var args, callback, err, otherArgs;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        callback = args[-1];
        otherArgs = args.slice(0, -1);
        err = fn.apply(null, otherArgs);
        return callback(err);
      };
    };
    _coerceToNode = function(value) {
      if (value instanceof exports.Node) {
        return value;
      } else if (value._quiverNode) {
        return value._quiverNode;
      } else {
        return new exports.Node(value);
      }
    };
    exports.Lock = (function() {
      function Lock() {
        this.queue = [];
      }

      Lock.prototype.acquire = function(callback) {
        var q, release;
        q = this.queue;
        release = function() {
          q.shift();
          if (q.length > 0) {
            return q[0](release);
          }
        };
        q.push(callback);
        if (q.length === 1) {
          callback(release);
        }
      };

      Lock.prototype.isLocked = function() {
        return this.queue.length > 0;
      };

      return Lock;

    })();
    LockedSet = exports.LockedSet = (function() {
      function LockedSet() {
        this.nodes = {};
      }

      LockedSet.prototype.acquireNode = function(node, callback) {
        if (this.nodes[node.id]) {
          callback();
        } else {
          node.lock.acquire((function(_this) {
            return function(release) {
              _this.nodes[node.id] = {
                node: node,
                release: release
              };
              return callback();
            };
          })(this));
        }
      };

      LockedSet.prototype.release = function() {
        var node, nodeId, _ref;
        _ref = this.nodes;
        for (nodeId in _ref) {
          node = _ref[nodeId];
          node.release();
        }
        this.nodes = {};
      };

      return LockedSet;

    })();
    exports.Node = (function() {
      function Node(payload) {
        var _base;
        this.payload = payload != null ? payload : {};
        this.inputs = [];
        this.outputs = [];
        this.updated = false;
        this.lock = new exports.Lock();
        this.id = _getUniqueId();
        (_base = this.payload)._quiverNode || (_base._quiverNode = this);
      }

      Node.prototype.pushInputs = function() {
        var value, values, _i, _len;
        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = values.length; _i < _len; _i++) {
          value = values[_i];
          this.inputs.push(_coerceToNode(value));
        }
      };

      Node.prototype.pushOutputs = function() {
        var value, values, _i, _len;
        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        for (_i = 0, _len = values.length; _i < _len; _i++) {
          value = values[_i];
          this.outputs.push(_coerceToNode(value));
        }
      };

      Node.prototype.execute = function(callback) {
        var inputPayloads, outputPayloads;
        this.updated = true;
        if (this.payload instanceof Function) {
          inputPayloads = _pluck(this.inputs, 'payload');
          outputPayloads = _pluck(this.outputs, 'payload');
          this.payload(inputPayloads, outputPayloads, callback);
        } else {
          callback();
        }
      };

      return Node;

    })();
    _walk = exports._walk = function(node, nodeInfo, lockedSet, callback, doIn, doOut) {
      lockedSet.acquireNode(node, function() {
        var inNode, outNode, tasks, _i, _j, _len, _len1, _name, _ref, _ref1;
        if (nodeInfo[_name = node.id] == null) {
          nodeInfo[_name] = {
            node: node,
            deps: []
          };
        }
        tasks = [];
        _ref = node.inputs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          inNode = _ref[_i];
          tasks.push(doIn(inNode, tasks));
        }
        _ref1 = node.outputs;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          outNode = _ref1[_j];
          tasks.push(doOut(outNode, tasks));
        }
        return async.parallel(tasks, function(err, results) {
          if (err) {
            throw err;
          }
          return callback();
        });
      });
    };
    _walkOut = exports._walkOut = function(node, nodeInfo, lockedSet, callback) {
      return _walk(node, nodeInfo, lockedSet, callback, function(inNode) {
        return function(cb) {
          return lockedSet.acquireNode(inNode, cb);
        };
      }, function(outNode) {
        return function(cb) {
          return lockedSet.acquireNode(outNode, function() {
            var done;
            done = function() {
              nodeInfo[outNode.id].deps.push(node.id + "");
              return cb();
            };
            if (nodeInfo[outNode.id]) {
              return done();
            } else {
              return _walkOut(outNode, nodeInfo, lockedSet, done);
            }
          });
        };
      });
    };
    _walkIn = exports._walkIn = function(node, nodeInfo, lockedSet, callback) {
      return _walk(node, nodeInfo, lockedSet, callback, function(inNode) {
        return function(cb) {
          return lockedSet.acquireNode(inNode, function() {
            if (inNode.updated) {
              return cb();
            } else {
              nodeInfo[node.id].deps.push(inNode.id + "");
              if (nodeInfo[inNode.id]) {
                return cb();
              } else {
                return _walkIn(inNode, nodeInfo, lockedSet, cb);
              }
            }
          });
        };
      }, function(outNode) {
        return function(cb) {
          return lockedSet.acquireNode(outNode, cb);
        };
      });
    };
    exports.push = function(node, callback) {
      var lockedSet, nodeInfo, releases, tasks;
      nodeInfo = {};
      releases = [];
      lockedSet = new LockedSet();
      tasks = {};
      node = node instanceof exports.Node ? node : node._quiverNode;
      _walkOut(node, nodeInfo, lockedSet, function() {
        var info, nodeId, _fn;
        _fn = function(info) {
          return tasks[nodeId] = info.deps.concat([
            function(cb) {
              return _.defer(function() {
                return info.node.execute(cb);
              });
            }
          ]);
        };
        for (nodeId in nodeInfo) {
          info = nodeInfo[nodeId];
          _fn(info);
        }
        return async.auto(tasks, function(err, results) {
          lockedSet.release();
          return typeof callback === "function" ? callback() : void 0;
        });
      });
    };
    exports.pull = function(node, callback) {
      var lockedSet, nodeInfo, releases, tasks;
      nodeInfo = {};
      releases = [];
      lockedSet = new LockedSet();
      tasks = {};
      node = node instanceof exports.Node ? node : node._quiverNode;
      _walkIn(node, nodeInfo, lockedSet, function() {
        var info, nodeId, _fn;
        _fn = function(info) {
          return tasks[nodeId] = info.deps.concat([
            function(cb) {
              return _.defer(function() {
                return info.node.execute(cb);
              });
            }
          ]);
        };
        for (nodeId in nodeInfo) {
          info = nodeInfo[nodeId];
          _fn(info);
        }
        return async.auto(tasks, function(err, results) {
          lockedSet.release();
          return typeof callback === "function" ? callback() : void 0;
        });
      });
    };
    exports.connect = function() {
      var arg, args, ls, node, prevNode, tasks, _fn, _i, _len;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      tasks = [];
      prevNode = null;
      ls = new LockedSet;
      _fn = function(prevNode, node) {
        return tasks.push(function(cb) {
          return ls.acquireNode(node, function() {
            if (prevNode) {
              prevNode.pushOutputs(node);
              node.pushInputs(prevNode);
            }
            return cb();
          });
        });
      };
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        arg = args[_i];
        node = _coerceToNode(arg);
        _fn(prevNode, node);
        prevNode = node;
      }
      async.parallel(tasks, function() {
        return ls.release();
      });
    };
    return exports;
  };

  if (typeof define !== "undefined" && define !== null) {
    define(moduleDef);
  } else if (typeof exports !== "undefined" && exports !== null) {
    moduleDef(require, exports, module);
  }

}).call(this);
