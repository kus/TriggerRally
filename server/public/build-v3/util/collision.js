// Generated by CoffeeScript 1.7.1

/*
 * Copyright (C) 2012 jareiko / http://www.jareiko.net/
 */


/*
 * Contact convention:
 *   normal: points from obj1 to obj2, and from pos2 to pos1
 *   pos1: contact point on surface of obj1
 *   pos2: contact point on surface of obj2
 *   depth: distance between pos1 and pos2
 *   surfacePos is deprecated, equivalent to pos2
 */

(function() {
  define(['THREE'], function(THREE) {
    var SphereList;
    return {
      SphereList: SphereList = (function() {
        var Vec3, tmpPt2Vec, tmpVec3a;

        Vec3 = THREE.Vector3;

        tmpVec3a = new Vec3();

        function SphereList(points) {
          this.points = points;
          if (points) {
            this._centerPoints();
          }
        }

        SphereList.prototype.clone = function() {
          var p, pt, sl;
          sl = new SphereList;
          sl.points = (function() {
            var _i, _len, _ref, _results;
            _ref = this.points;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              pt = _ref[_i];
              p = pt.clone();
              p.radius = pt.radius;
              _results.push(p);
            }
            return _results;
          }).call(this);
          sl.bounds = {
            center: this.bounds.center.clone(),
            min: this.bounds.min.clone(),
            max: this.bounds.max.clone(),
            radius: this.bounds.radius
          };
          return sl;
        };

        SphereList.prototype._centerPoints = function() {
          var center, max, min, pt, rad, radius, _i, _j, _len, _len1, _ref, _ref1;
          min = new Vec3(Infinity, Infinity, Infinity);
          max = new Vec3(-Infinity, -Infinity, -Infinity);
          _ref = this.points;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            pt = _ref[_i];
            rad = pt.radius;
            min.x = Math.min(min.x, pt.x - rad);
            min.y = Math.min(min.y, pt.y - rad);
            min.z = Math.min(min.z, pt.z - rad);
            max.x = Math.max(max.x, pt.x + rad);
            max.y = Math.max(max.y, pt.y + rad);
            max.z = Math.max(max.z, pt.z + rad);
          }
          center = min.clone().addSelf(max).multiplyScalar(0.5);
          radius = 0;
          _ref1 = this.points;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            pt = _ref1[_j];
            pt.subSelf(center);
            radius = Math.max(radius, pt.length() + pt.radius);
          }
          return this.bounds = {
            center: center,
            min: min,
            max: max,
            radius: radius
          };
        };

        SphereList.prototype.collideSphere = function(sphere) {
          var bothRadius, center1, contact, contacts, dist, pt1, sl1, _i, _len, _ref;
          sl1 = this;
          contacts = [];
          center1 = sl1.bounds.center;
          tmpVec3a.sub(sphere, center1);
          if (!(tmpVec3a.length() < sl1.bounds.radius + sphere.radius)) {
            return contacts;
          }
          _ref = sl1.points;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            pt1 = _ref[_i];
            tmpVec3a.sub(sphere, pt1);
            tmpVec3a.subSelf(center1);
            dist = tmpVec3a.length();
            bothRadius = pt1.radius + sphere.radius;
            if (!(dist < bothRadius)) {
              continue;
            }
            tmpVec3a.multiplyScalar(1 / dist);
            contact = {
              normal: tmpVec3a.clone(),
              depth: bothRadius - dist,
              pos1: tmpVec3a.clone().multiplyScalar(pt1.radius).addSelf(pt1).addSelf(center1),
              pos2: tmpVec3a.clone().multiplyScalar(-sphere.radius).addSelf(sphere)
            };
            contacts.push(contact);
          }
          return contacts;
        };

        tmpPt2Vec = new Vec3();

        SphereList.prototype.collideSphereList = function(sl2) {
          var center1, center2, contacts, pt2, sl1, _i, _len, _ref;
          sl1 = this;
          contacts = [];
          center1 = sl1.bounds.center;
          center2 = sl2.bounds.center;
          tmpVec3a.sub(center2, center1);
          if (!(tmpVec3a.length() < sl1.bounds.radius + sl2.bounds.radius)) {
            return contacts;
          }
          _ref = sl2.points;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            pt2 = _ref[_i];
            tmpPt2Vec.copy(pt2);
            tmpPt2Vec.addSelf(center2);
            tmpPt2Vec.radius = pt2.radius;
            Array.prototype.push.apply(contacts, this.collideSphere(tmpPt2Vec));
          }
          return contacts;
        };

        return SphereList;

      })()
    };
  });

}).call(this);
