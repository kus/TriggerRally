// Generated by CoffeeScript 1.7.1

/*
 * Copyright (C) 2012 jareiko / http://www.jareiko.net/
 */

(function() {
  define(['util/pubsub'], function(utilPubsub) {
    var KEYS, Synchro, applyDiff, filterObject, objDiff;
    filterObject = function(obj, keys) {
      var el, key, result, subKeys, val, _i, _len, _results;
      if (_.isArray(keys)) {
        subKeys = keys[0];
        _results = [];
        for (_i = 0, _len = obj.length; _i < _len; _i++) {
          el = obj[_i];
          _results.push(filterObject(el, subKeys));
        }
        return _results;
      } else if (typeof keys === 'object') {
        result = {};
        for (key in keys) {
          val = keys[key];
          result[key] = filterObject(obj[key], val);
        }
        return result;
      } else {
        return obj.toFixed(keys);
      }
    };
    objDiff = function(a, b) {
      var aVal, bVal, c, changed, diff, el, index, k, r, _i, _len;
      diff = {};
      for (k in a) {
        aVal = a[k];
        bVal = b[k];
        if (_.isArray(aVal)) {
          changed = false;
          c = [];
          for (index = _i = 0, _len = aVal.length; _i < _len; index = ++_i) {
            el = aVal[index];
            r = objDiff(el, bVal[index]);
            if (!_.isEmpty(r)) {
              changed = true;
            }
            c.push(r);
          }
          if (changed) {
            diff[k] = c;
          }
        } else if (typeof aVal === 'object') {
          c = objDiff(aVal, bVal);
          if (!_.isEmpty(c)) {
            diff[k] = c;
          }
        } else {
          if (aVal !== bVal) {
            diff[k] = aVal;
          }
        }
      }
      return diff;
    };
    applyDiff = function(obj, diff, keyMap) {
      var el, index, key, val, _i, _len;
      if (_.isArray(diff)) {
        for (index = _i = 0, _len = diff.length; _i < _len; index = ++_i) {
          el = diff[index];
          obj[index] = applyDiff(obj[index], el, keyMap);
        }
        return obj;
      } else if (typeof diff === 'object') {
        if (keyMap) {
          for (key in diff) {
            val = diff[key];
            obj[keyMap[key]] = applyDiff(obj[keyMap[key]], val, keyMap);
          }
        } else {
          for (key in diff) {
            val = diff[key];
            obj[key] = applyDiff(obj[key], val);
          }
        }
        return obj;
      } else {
        return parseFloat(diff);
      }
    };
    KEYS = {
      nextCpIndex: 0,
      vehicle: {
        body: {
          pos: {
            x: 3,
            y: 3,
            z: 3
          },
          ori: {
            x: 3,
            y: 3,
            z: 3,
            w: 3
          },
          linVel: {
            x: 3,
            y: 3,
            z: 3
          },
          angMom: {
            x: 3,
            y: 3,
            z: 3
          }
        },
        wheels: [
          {
            spinVel: 1
          }
        ],
        engineAngVel: 3,
        controller: {
          input: {
            forward: 0,
            back: 0,
            left: 0,
            right: 0,
            handbrake: 0
          }
        }
      }
    };
    return {
      Synchro: Synchro = (function() {
        function Synchro(game) {
          var progresses, pubsub;
          this.game = game;
          this.socket = io.connect('/');
          pubsub = new utilPubsub.PubSub();
          this.on = pubsub.subscribe.bind(pubsub);
          game.on('addvehicle', (function(_this) {
            return function(vehicle, progress) {
              if (!vehicle.cfg.isRemote) {
                _this._sendVehicleUpdates(vehicle, progress);
              }
            };
          })(this));
          progresses = {};
          this.socket.on('addcar', function(data) {
            var config, wireId;
            wireId = data.wireId, config = data.config;
            if ((config != null) && (progresses[wireId] == null)) {
              return game.addCarConfig(config, function(progress) {
                return progresses[wireId] = progress;
              });
            }
          });
          this.socket.on('deletecar', function(data) {
            var wireId;
            wireId = data.wireId;
            if (progresses[wireId] != null) {
              game.deleteCar(progresses[wireId]);
              return delete progresses[wireId];
            }
          });
          this.socket.on('s2c', function(data) {
            var carstate, progress, wireId;
            wireId = data.wireId, carstate = data.carstate;
            progress = progresses[wireId];
            if (progress != null) {
              applyDiff(progress, carstate);
            }
          });
        }

        Synchro.prototype._sendVehicleUpdates = function(vehicle, progress) {
          var lastState;
          this.socket.emit('c2s', {
            config: vehicle.cfg
          });
          lastState = null;
          setInterval((function(_this) {
            return function() {
              var diff, state;
              state = filterObject(progress, KEYS);
              if (lastState != null) {
                diff = objDiff(state, lastState);
                lastState = state;
                if (!_.isEmpty(diff)) {
                  return _this.socket.emit('c2s', {
                    carstate: diff
                  });
                }
              } else {
                return lastState = state;
              }
            };
          })(this), 200);
        };

        return Synchro;

      })()
    };
  });

}).call(this);
