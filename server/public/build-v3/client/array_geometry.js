// Generated by CoffeeScript 1.7.1

/*
 * Copyright (C) 2012 jareiko / http://www.jareiko.net/
 */

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['THREE'], function(THREE) {
    var ArrayGeometry;
    return {
      ArrayGeometry: ArrayGeometry = (function(_super) {
        __extends(ArrayGeometry, _super);

        function ArrayGeometry() {
          ArrayGeometry.__super__.constructor.call(this);
          this.wireframe = false;
        }

        ArrayGeometry.prototype.doubleTriangles = function() {
          var i, indices, newIndices;
          indices = this.attributes["index"].array;
          newIndices = [];
          i = 0;
          while (i < indices.length - 2) {
            newIndices.push(indices[i + 0], indices[i + 1], indices[i + 1]);
            newIndices.push(indices[i + 2], indices[i + 2], indices[i + 0]);
            i += 3;
          }
          this.attributes["index"].array = newIndices;
        };

        ArrayGeometry.prototype.removeIndices = function() {
          var attrib, i, indices, itemSize, j, key, newArray, oldArray, _i, _j, _ref, _ref1;
          indices = this.attributes['index'].array;
          delete this.attributes['index'];
          _ref = this.attributes;
          for (key in _ref) {
            attrib = _ref[key];
            itemSize = attrib.itemSize;
            oldArray = attrib.array;
            newArray = attrib.array = new Float32Array(indices.length * itemSize);
            for (i = _i = 0, _ref1 = indices.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
              for (j = _j = 0; 0 <= itemSize ? _j < itemSize : _j > itemSize; j = 0 <= itemSize ? ++_j : --_j) {
                newArray[i * itemSize + j] = oldArray[indices[i] * itemSize + j];
              }
            }
          }
          this.attributes['position'].numItems = indices.length * 3;
        };

        ArrayGeometry.prototype.updateOffsets = function() {
          var MAX_INDEX, PRIMITIVE_SIZE, addOffset, attrib, elem, i, indices, key, maxElem, maxIndexFound, minIndexFound, newMaxIndexFound, newMinIndexFound, offset, primMaxIndex, primMinIndex, type, _i, _ref;
          if (this.wireframe) {
            this.doubleTriangles();
          }
          this.offsets = [];
          offset = {
            count: 0,
            start: 0
          };
          elem = 0;
          PRIMITIVE_SIZE = this.wireframe ? 2 : 3;
          MAX_INDEX = 65535;
          minIndexFound = Infinity;
          maxIndexFound = 0;
          indices = this.attributes["index"].array;
          maxElem = indices.length - PRIMITIVE_SIZE + 1;
          addOffset = (function(_this) {
            return function() {
              var i, _i, _ref;
              offset.index = minIndexFound;
              for (i = _i = _ref = offset.start; _ref <= elem ? _i < elem : _i > elem; i = _ref <= elem ? ++_i : --_i) {
                indices[i] -= minIndexFound;
              }
              return _this.offsets.push(offset);
            };
          })(this);
          while (elem < maxElem) {
            primMinIndex = Infinity;
            primMaxIndex = 0;
            for (i = _i = 0; 0 <= PRIMITIVE_SIZE ? _i < PRIMITIVE_SIZE : _i > PRIMITIVE_SIZE; i = 0 <= PRIMITIVE_SIZE ? ++_i : --_i) {
              primMinIndex = Math.min(primMinIndex, indices[elem + i]);
              primMaxIndex = Math.max(primMaxIndex, indices[elem + i]);
            }
            newMinIndexFound = Math.min(minIndexFound, primMinIndex);
            newMaxIndexFound = Math.max(maxIndexFound, primMaxIndex);
            if (newMaxIndexFound - newMinIndexFound > MAX_INDEX) {
              addOffset();
              offset = {
                count: 0,
                start: elem
              };
              minIndexFound = primMinIndex;
              maxIndexFound = primMaxIndex;
            } else {
              minIndexFound = newMinIndexFound;
              maxIndexFound = newMaxIndexFound;
            }
            elem += PRIMITIVE_SIZE;
            offset.count += PRIMITIVE_SIZE;
          }
          if (offset.count > 0) {
            addOffset();
          }
          _ref = this.attributes;
          for (key in _ref) {
            attrib = _ref[key];
            type = key === "index" ? Uint16Array : Float32Array;
            attrib.array = new type(attrib.array);
          }
        };

        ArrayGeometry.prototype.addGeometry = function(geom) {
          var face, faceIndex, norm, offsetPosition, pt, pts, uv, uvs, v, _base, _base1, _base2, _base3, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
          if ((_base = this.attributes)["index"] == null) {
            _base["index"] = {
              array: []
            };
          }
          if ((_base1 = this.attributes)["position"] == null) {
            _base1["position"] = {
              array: [],
              itemSize: 3
            };
          }
          if ((_base2 = this.attributes)["normal"] == null) {
            _base2["normal"] = {
              array: [],
              itemSize: 3
            };
          }
          if ((_base3 = this.attributes)["uv"] == null) {
            _base3["uv"] = {
              array: [],
              itemSize: 2
            };
          }
          pts = ['a', 'b', 'c', 'd'];
          offsetPosition = this.attributes["position"].array.length;
          _ref = geom.vertices;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            this.attributes["position"].array.push(v.x, v.y, v.z);
          }
          _ref1 = geom.faces;
          for (faceIndex = _j = 0, _len1 = _ref1.length; _j < _len1; faceIndex = ++_j) {
            face = _ref1[faceIndex];
            if (face.d != null) {
              this.attributes["index"].array.push(face.a, face.b, face.d);
              this.attributes["index"].array.push(face.b, face.c, face.d);
            } else {
              this.attributes["index"].array.push(face.a, face.b, face.c);
            }
            _ref2 = face.vertexNormals;
            for (pt = _k = 0, _len2 = _ref2.length; _k < _len2; pt = ++_k) {
              norm = _ref2[pt];
              this.attributes["normal"].array[face[pts[pt]] * 3 + 0] = norm.x;
              this.attributes["normal"].array[face[pts[pt]] * 3 + 1] = norm.y;
              this.attributes["normal"].array[face[pts[pt]] * 3 + 2] = norm.z;
            }
            uvs = geom.faceVertexUvs[0][faceIndex];
            for (pt = _l = 0, _len3 = uvs.length; _l < _len3; pt = ++_l) {
              uv = uvs[pt];
              this.attributes["uv"].array[face[pts[pt]] * 2 + 0] = uv.x;
              this.attributes["uv"].array[face[pts[pt]] * 2 + 1] = uv.y;
            }
          }
        };

        ArrayGeometry.prototype.mergeMesh = function(mesh) {
          var geom2, hasNorms, i, idx, indexArray, matrix, matrixRotation, normalArray, norms, positionArray, posns, tmpVec3, vertexOffset, _base, _base1, _base2, _base3, _i, _len, _ref;
          if ((_base = this.attributes)["index"] == null) {
            _base["index"] = {
              array: []
            };
          }
          if ((_base1 = this.attributes)["position"] == null) {
            _base1["position"] = {
              array: [],
              itemSize: 3
            };
          }
          if ((_base2 = this.attributes)["normal"] == null) {
            _base2["normal"] = {
              array: [],
              itemSize: 3
            };
          }
          if ((_base3 = this.attributes)["uv"] == null) {
            _base3["uv"] = {
              array: [],
              itemSize: 2
            };
          }
          vertexOffset = this.attributes["position"].array.length / 3;
          geom2 = mesh.geometry;
          tmpVec3 = new THREE.Vector3;
          if (mesh.matrixAutoUpdate) {
            mesh.updateMatrix();
          }
          matrix = mesh.matrix;
          matrixRotation = new THREE.Matrix4();
          matrixRotation.extractRotation(matrix, mesh.scale);
          i = 0;
          posns = geom2.attributes["position"].array;
          norms = geom2.attributes["normal"].array;
          positionArray = this.attributes["position"].array;
          normalArray = this.attributes["normal"].array;
          hasNorms = (norms != null) && norms.length === posns.length;
          while (i < posns.length) {
            tmpVec3.set(posns[i + 0], posns[i + 1], posns[i + 2]);
            matrix.multiplyVector3(tmpVec3);
            positionArray.push(tmpVec3.x, tmpVec3.y, tmpVec3.z);
            if (hasNorms) {
              tmpVec3.set(norms[i + 0], norms[i + 1], norms[i + 2]);
              matrixRotation.multiplyVector3(tmpVec3);
              normalArray.push(tmpVec3.x, tmpVec3.y, tmpVec3.z);
            }
            i += 3;
          }
          this.attributes["uv"].array = this.attributes["uv"].array.concat(geom2.attributes["uv"].array);
          indexArray = this.attributes["index"].array;
          _ref = geom2.attributes["index"].array;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            idx = _ref[_i];
            indexArray.push(idx + vertexOffset);
          }
        };

        ArrayGeometry.prototype.computeBoundingSphere = function() {
          return this.computeBounds();
        };

        ArrayGeometry.prototype.computeBoundingBox = function() {
          return this.computeBounds();
        };

        ArrayGeometry.prototype.computeBounds = function() {
          var bb, i, maxRadius, numVerts, posns, radius, x, y, z;
          bb = {
            min: new THREE.Vector3(Infinity, Infinity, Infinity),
            max: new THREE.Vector3(-Infinity, -Infinity, -Infinity)
          };
          maxRadius = 0;
          i = 0;
          posns = this.attributes["position"].array;
          numVerts = posns.length;
          while (i < numVerts) {
            x = posns[i + 0];
            y = posns[i + 1];
            z = posns[i + 2];
            bb.min.x = Math.min(bb.min.x, x);
            bb.max.x = Math.max(bb.max.x, x);
            bb.min.y = Math.min(bb.min.y, y);
            bb.max.y = Math.max(bb.max.y, y);
            bb.min.z = Math.min(bb.min.z, z);
            bb.max.z = Math.max(bb.max.z, z);
            radius = Math.sqrt(x * x + y * y + z * z);
            maxRadius = Math.max(maxRadius, radius);
            i += 3;
          }
          this.boundingBox = bb;
          this.boundingSphere = {
            radius: maxRadius
          };
        };

        return ArrayGeometry;

      })(THREE.BufferGeometry)
    };
  });

}).call(this);
