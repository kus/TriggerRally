// Generated by CoffeeScript 1.7.1

/*
 * Copyright (C) 2012 jareiko / http://www.jareiko.net/
 */

(function() {
  var __slice = [].slice;

  define(['THREE', 'underscore', 'client/audio', 'client/car', 'client/misc', 'client/scenery', 'client/terrain', 'game/track', 'game/synchro', 'util/pubsub', 'util/quiver', 'util/util'], function(THREE, _, clientAudio, clientCar, clientMisc, clientScenery, clientTerrain, gameTrack, synchro, pubsub, quiver, util) {
    var CamControl, CamTerrainClipping, CarControl, Dust, GamepadController, KEYCODE, KeyboardController, MAP_RANGE, PULLTOWARD, RenderCheckpointArrows, RenderCheckpointsDrive, RenderCheckpointsEditor, RenderDials, SunLight, TriggerClient, Vec2, Vec3, Vec4, WheelController, deadZone, gamepadType, getGamepads, isModifierKey, keyWeCareAbout, projector, tmpVec3a;
    Vec2 = THREE.Vector2;
    Vec3 = THREE.Vector3;
    Vec4 = THREE.Vector4;
    PULLTOWARD = util.PULLTOWARD;
    MAP_RANGE = util.MAP_RANGE;
    KEYCODE = util.KEYCODE;
    deadZone = util.deadZone;
    projector = new THREE.Projector;
    tmpVec3a = new Vec3;
    RenderCheckpointsEditor = (function() {
      function RenderCheckpointsEditor(scene, root) {
        var meshes, reset;
        meshes = [];
        (reset = function() {
          var checkpoints, cp, mesh, _i, _len, _ref, _ref1;
          for (_i = 0, _len = meshes.length; _i < _len; _i++) {
            mesh = meshes[_i];
            scene.remove(mesh);
          }
          checkpoints = (_ref = root.track) != null ? (_ref1 = _ref.config) != null ? _ref1.course.checkpoints.models : void 0 : void 0;
          if (!checkpoints) {
            return;
          }
          return meshes = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = checkpoints.length; _j < _len1; _j++) {
              cp = checkpoints[_j];
              mesh = clientMisc.checkpointMesh();
              Vec3.prototype.set.apply(mesh.position, cp.pos);
              scene.add(mesh);
              _results.push(mesh);
            }
            return _results;
          })();
        })();
        root.on('change:track.config.course.checkpoints.', reset);
        root.on('add:track.config.course.checkpoints.', reset);
        root.on('remove:track.config.course.checkpoints.', reset);
        root.on('reset:track.config.course.checkpoints.', reset);
        this.destroy = function() {
          var mesh, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = meshes.length; _i < _len; _i++) {
            mesh = meshes[_i];
            _results.push(scene.remove(mesh));
          }
          return _results;
        };
      }

      RenderCheckpointsEditor.prototype.update = function(camera, delta) {};

      return RenderCheckpointsEditor;

    })();
    RenderCheckpointsDrive = (function() {
      function RenderCheckpointsDrive(scene, root) {
        this.root = root;
        this.ang = 0;
        this.mesh = clientMisc.checkpointMesh();
        this.initPos = this.mesh.position.clone();
        this.current = 0;
        scene.add(this.mesh);
      }

      RenderCheckpointsDrive.prototype.destroy = function() {
        return this.mesh.parent.remove(this.mesh);
      };

      RenderCheckpointsDrive.prototype.update = function(camera, delta) {
        var meshPos, pull, targetCp;
        targetCp = this.root.track.config.course.checkpoints.at(this.current);
        if (targetCp == null) {
          return;
        }
        this.mesh.rotation.z += delta * 3;
        meshPos = this.mesh.position;
        pull = delta * 2;
        if (this.current === 0) {
          pull = 1;
        }
        meshPos.x = PULLTOWARD(meshPos.x, targetCp.pos[0] + this.initPos.x, pull);
        meshPos.y = PULLTOWARD(meshPos.y, targetCp.pos[1] + this.initPos.y, pull);
        return meshPos.z = PULLTOWARD(meshPos.z, targetCp.pos[2] + this.initPos.z, pull);
      };

      RenderCheckpointsDrive.prototype.highlightCheckpoint = function(i) {
        return this.current = i;
      };

      return RenderCheckpointsDrive;

    })();
    RenderDials = (function() {
      function RenderDials(scene, vehic) {
        var geom, mat;
        this.vehic = vehic;
        geom = new THREE.Geometry();
        geom.vertices.push(new Vec3(1, 0, 0));
        geom.vertices.push(new Vec3(-0.1, 0.02, 0));
        geom.vertices.push(new Vec3(-0.1, -0.02, 0));
        geom.faces.push(new THREE.Face3(0, 1, 2));
        geom.computeCentroids();
        mat = new THREE.MeshBasicMaterial({
          color: 0x206020,
          blending: THREE.AdditiveBlending,
          transparent: 1,
          depthTest: false
        });
        this.revMeter = new THREE.Mesh(geom, mat);
        this.revMeter.position.x = -1.3;
        this.revMeter.position.y = -0.2;
        this.revMeter.scale.multiplyScalar(0.4);
        scene.add(this.revMeter);
        this.speedMeter = new THREE.Mesh(geom, mat);
        this.speedMeter.position.x = -1.3;
        this.speedMeter.position.y = -0.7;
        this.speedMeter.scale.multiplyScalar(0.4);
        scene.add(this.speedMeter);
        this.$digital = $(".speedo");
      }

      RenderDials.prototype.destroy = function() {
        this.revMeter.parent.remove(this.revMeter);
        return this.speedMeter.parent.remove(this.speedMeter);
      };

      RenderDials.prototype.update = function(camera, delta) {
        var convertKMH, speed, vehic;
        vehic = this.vehic;
        convertKMH = 3.6;
        this.revMeter.rotation.z = -2.5 - 4.5 * ((vehic.engineAngVelSmoothed - vehic.engineIdle) / (vehic.engineRedline - vehic.engineIdle));
        speed = Math.abs(vehic.differentialAngVel) * vehic.avgDriveWheelRadius * convertKMH;
        this.speedMeter.rotation.z = -2.5 - 4.5 * speed * 0.004;
        speed = vehic.body.getLinearVel().length() * convertKMH;
        this.$digital.text(speed.toFixed(0) + " km/h");
      };

      RenderDials.prototype.highlightCheckpoint = function(i) {
        this.current = i;
      };

      return RenderDials;

    })();
    RenderCheckpointArrows = (function() {
      function RenderCheckpointArrows(scene, progress) {
        var geom, mat, mat2;
        this.scene = scene;
        this.progress = progress;
        mat = new THREE.MeshBasicMaterial({
          color: 0x206020,
          blending: THREE.AdditiveBlending,
          transparent: 1,
          depthTest: false
        });
        mat2 = new THREE.MeshBasicMaterial({
          color: 0x051005,
          blending: THREE.AdditiveBlending,
          transparent: 1,
          depthTest: false
        });
        geom = new THREE.Geometry();
        geom.vertices.push(new Vec3(0, 0, 0.6));
        geom.vertices.push(new Vec3(0.1, 0, 0.3));
        geom.vertices.push(new Vec3(-0.1, 0, 0.3));
        geom.vertices.push(new Vec3(0.1, 0, -0.2));
        geom.vertices.push(new Vec3(-0.1, 0, -0.2));
        geom.faces.push(new THREE.Face3(0, 2, 1));
        geom.faces.push(new THREE.Face4(1, 2, 4, 3));
        this.meshArrow = new THREE.Mesh(geom, mat);
        this.meshArrow.position.set(0, 1, -2);
        this.meshArrow2 = new THREE.Mesh(geom, mat2);
        this.meshArrow2.position.set(0, 0, 0.8);
        scene.add(this.meshArrow);
        this.meshArrow.add(this.meshArrow2);
      }

      RenderCheckpointArrows.prototype.destroy = function() {
        return this.meshArrow.parent.remove(this.meshArrow);
      };

      RenderCheckpointArrows.prototype.update = function(camera, delta) {
        var camMatrixEl, carPos, cpVec, cpVecCamSpace, nextCp, nextCp2;
        nextCp = this.progress.nextCheckpoint(0);
        nextCp2 = this.progress.nextCheckpoint(1);
        carPos = this.progress.vehicle.body.pos;
        camMatrixEl = camera.matrixWorld.elements;
        this.meshArrow.visible = nextCp != null;
        if (nextCp) {
          cpVec = new Vec2(nextCp.pos[0] - carPos.x, nextCp.pos[1] - carPos.y);
          cpVecCamSpace = new Vec2(cpVec.x * camMatrixEl[1] + cpVec.y * camMatrixEl[9], cpVec.x * camMatrixEl[0] + cpVec.y * camMatrixEl[8]);
          this.meshArrow.rotation.y = Math.atan2(cpVecCamSpace.y, cpVecCamSpace.x);
        }
        this.meshArrow2.visible = nextCp2 != null;
        if (nextCp2) {
          cpVec = new Vec2(nextCp2.pos[0] - carPos.x, nextCp2.pos[1] - carPos.y);
          cpVecCamSpace = new Vec2(cpVec.x * camMatrixEl[1] + cpVec.y * camMatrixEl[9], cpVec.x * camMatrixEl[0] + cpVec.y * camMatrixEl[8]);
          return this.meshArrow2.rotation.y = Math.atan2(cpVecCamSpace.y, cpVecCamSpace.x) - this.meshArrow.rotation.y;
        }
      };

      return RenderCheckpointArrows;

    })();
    CamControl = (function() {
      function CamControl(camera, car) {
        var chaseCam, insideCam, insideCam2, pullCameraQuat, pullTransformedQuat, translate, translateCam, wheelCam;
        this.camera = camera;
        this.car = car;
        this.mode = 0;
        pullTransformedQuat = function(quat, quatTarget, amount) {
          quat.x = PULLTOWARD(quat.x, -quatTarget.z, amount);
          quat.y = PULLTOWARD(quat.y, quatTarget.w, amount);
          quat.z = PULLTOWARD(quat.z, quatTarget.x, amount);
          quat.w = PULLTOWARD(quat.w, -quatTarget.y, amount);
          return quat.normalize();
        };
        translate = function(pos, matrix, x, y, z) {
          var el;
          el = matrix.elements;
          pos.x += el[0] * x + el[4] * y + el[8] * z;
          pos.y += el[1] * x + el[5] * y + el[9] * z;
          return pos.z += el[2] * x + el[6] * y + el[10] * z;
        };
        pullCameraQuat = function(cam, car, amount) {
          cam.useQuaternion = true;
          pullTransformedQuat(cam.quaternion, car.root.quaternion, amount);
          return cam.updateMatrix();
        };
        translateCam = function(cam, car, x, y, z) {
          cam.position.copy(car.root.position);
          translate(cam.position, cam.matrix, x, y, z);
          return cam.matrix.setPosition(cam.position);
        };
        chaseCam = {
          update: function(cam, car, delta) {
            var camDelta, lookPos, matrix, offset, targetPos, _ref;
            if ((_ref = car.bodyMesh) != null) {
              _ref.visible = true;
            }
            targetPos = car.root.position.clone();
            targetPos.addSelf(car.vehic.body.linVel.clone().multiplyScalar(.17));
            offset = car.config.chaseCamOffset || [0, 1.2, -2.9];
            matrix = car.root.matrix;
            targetPos.addSelf(matrix.getColumnX().multiplyScalar(offset[0]));
            targetPos.addSelf(matrix.getColumnY().multiplyScalar(offset[1]));
            targetPos.addSelf(matrix.getColumnZ().multiplyScalar(offset[2]));
            camDelta = delta * 5;
            cam.position.x = PULLTOWARD(cam.position.x, targetPos.x, camDelta);
            cam.position.y = PULLTOWARD(cam.position.y, targetPos.y, camDelta);
            cam.position.z = PULLTOWARD(cam.position.z, targetPos.z, camDelta);
            cam.useQuaternion = false;
            pullTransformedQuat(cam.quaternion, car.root.quaternion, 1);
            lookPos = car.root.position.clone();
            translate(lookPos, car.root.matrix, 0, 0.7, 0);
            cam.lookAt(lookPos);
          }
        };
        insideCam = {
          update: function(cam, car, delta) {
            var _ref;
            if ((_ref = car.bodyMesh) != null) {
              _ref.visible = true;
            }
            pullCameraQuat(cam, car, delta * 30);
            translateCam(cam, car, 0, 0.7, -1);
          }
        };
        insideCam2 = {
          update: function(cam, car, delta) {
            var _ref;
            if ((_ref = car.bodyMesh) != null) {
              _ref.visible = false;
            }
            pullCameraQuat(cam, car, 1);
            translateCam(cam, car, 0, 0.7, -1);
          }
        };
        wheelCam = {
          update: function(cam, car, delta) {
            var _ref;
            if ((_ref = car.bodyMesh) != null) {
              _ref.visible = true;
            }
            pullCameraQuat(cam, car, delta * 100);
            translateCam(cam, car, 1, 0, -0.4);
          }
        };
        this.modes = [chaseCam, insideCam, insideCam2, wheelCam];
        return;
      }

      CamControl.prototype.getMode = function() {
        return this.modes[this.mode];
      };

      CamControl.prototype.update = function(camera, delta) {
        if (this.car.root != null) {
          this.getMode().update(this.camera, this.car, delta);
        }
      };

      CamControl.prototype.nextMode = function() {
        return this.mode = (this.mode + 1) % this.modes.length;
      };

      return CamControl;

    })();
    CamTerrainClipping = (function() {
      function CamTerrainClipping(camera, terrain) {
        this.camera = camera;
        this.terrain = terrain;
        return;
      }

      CamTerrainClipping.prototype.update = function(camera, delta) {
        var camPos, contact, terrainHeight;
        camPos = this.camera.position;
        contact = this.terrain.getContactRayZ(camPos.x, camPos.y);
        terrainHeight = contact.surfacePos.z;
        camPos.z = Math.max(camPos.z, terrainHeight + 0.2);
      };

      return CamTerrainClipping;

    })();
    KeyboardController = (function() {
      var BRAKE_RESPONSE, HANDBRAKE_RESPONSE, THROTTLE_RESPONSE, TURN_RESPONSE;

      THROTTLE_RESPONSE = 8;

      BRAKE_RESPONSE = 5;

      HANDBRAKE_RESPONSE = 20;

      TURN_RESPONSE = 5;

      function KeyboardController(vehic, client) {
        this.vehic = vehic;
        this.client = client;
        this.controls = util.deepClone(this.vehic.controller.input);
      }

      KeyboardController.prototype.update = function(delta) {
        var brake, controls, handbrake, keyDown, left, right, throttle;
        keyDown = this.client.keyDown;
        throttle = keyDown[KEYCODE['UP']] || keyDown[KEYCODE['W']] ? 1 : 0;
        brake = keyDown[KEYCODE['DOWN']] || keyDown[KEYCODE['S']] ? 1 : 0;
        left = keyDown[KEYCODE['LEFT']] || keyDown[KEYCODE['A']] ? 1 : 0;
        right = keyDown[KEYCODE['RIGHT']] || keyDown[KEYCODE['D']] ? 1 : 0;
        handbrake = keyDown[KEYCODE['SPACE']] ? 1 : 0;
        controls = this.controls;
        controls.throttle = PULLTOWARD(controls.throttle, throttle, THROTTLE_RESPONSE * delta);
        controls.brake = PULLTOWARD(controls.brake, brake, BRAKE_RESPONSE * delta);
        controls.handbrake = PULLTOWARD(controls.handbrake, handbrake, HANDBRAKE_RESPONSE * delta);
        return controls.turn = PULLTOWARD(controls.turn, left - right, TURN_RESPONSE * delta);
      };

      return KeyboardController;

    })();
    GamepadController = (function() {
      function GamepadController(vehic, gamepad) {
        this.vehic = vehic;
        this.gamepad = gamepad;
        this.controls = util.deepClone(this.vehic.controller.input);
      }

      GamepadController.prototype.update = function(delta) {
        var axes, axes0, axes3, buttons, controls;
        controls = this.controls;
        axes = this.gamepad.axes;
        buttons = this.gamepad.buttons;
        axes0 = deadZone(axes[0], 0.05);
        axes3 = deadZone(axes[3], 0.05);
        controls.throttle = Math.max(0, -axes3, buttons[0] || 0, buttons[5] || 0, buttons[7] || 0);
        controls.brake = Math.max(0, axes3, buttons[4] || 0, buttons[6] || 0);
        controls.handbrake = buttons[2] || 0;
        return controls.turn = -axes0 - (buttons[15] || 0) + (buttons[14] || 0);
      };

      return GamepadController;

    })();
    WheelController = (function() {
      function WheelController(vehic, gamepad) {
        this.vehic = vehic;
        this.gamepad = gamepad;
        this.controls = util.deepClone(this.vehic.controller.input);
      }

      WheelController.prototype.update = function(delta) {
        var axes, axes0, axes1, buttons, controls;
        controls = this.controls;
        axes = this.gamepad.axes;
        buttons = this.gamepad.buttons;
        axes0 = deadZone(axes[0], 0.01);
        axes1 = deadZone(axes[1], 0.01);
        controls.throttle = Math.max(0, -axes1);
        controls.brake = Math.max(0, axes1);
        controls.handbrake = Math.max(buttons[6] || 0, buttons[7] || 0);
        return controls.turn = -axes0;
      };

      return WheelController;

    })();
    getGamepads = function() {
      var nav;
      nav = navigator;
      return (typeof nav.getGamepads === "function" ? nav.getGamepads() : void 0) || nav.gamepads || (typeof nav.mozGetGamepads === "function" ? nav.mozGetGamepads() : void 0) || nav.mozGamepads || (typeof nav.webkitGetGamepads === "function" ? nav.webkitGetGamepads() : void 0) || nav.webkitGamepads || [];
    };
    gamepadType = function(id) {
      if (/Racing Wheel/.test(id)) {
        return WheelController;
      } else {
        return GamepadController;
      }
    };
    CarControl = (function() {
      function CarControl(vehic, client) {
        this.vehic = vehic;
        this.client = client;
        this.controllers = [];
        this.gamepadMap = {};
        this.controllers.push(new KeyboardController(vehic, client));
      }

      CarControl.prototype.update = function(camera, delta) {
        var controller, controls, gamepad, i, key, type, _i, _j, _len, _len1, _ref, _ref1;
        _ref = getGamepads();
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          gamepad = _ref[i];
          if ((gamepad != null) && !(i in this.gamepadMap)) {
            this.gamepadMap[i] = true;
            type = gamepadType(gamepad.id);
            this.controllers.push(new type(this.vehic, gamepad));
          }
        }
        controls = this.vehic.controller.input;
        for (key in controls) {
          controls[key] = 0;
        }
        _ref1 = this.controllers;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          controller = _ref1[_j];
          controller.update(delta);
          for (key in controls) {
            controls[key] += controller.controls[key];
          }
        }
      };

      return CarControl;

    })();
    SunLight = (function() {
      function SunLight(scene) {
        var sunLight;
        sunLight = this.sunLight = new THREE.DirectionalLight(0xffe0bb);
        sunLight.intensity = 1.3;
        this.sunLightPos = new Vec3(-6, 7, 10);
        sunLight.position.copy(this.sunLightPos);
        sunLight.castShadow = true;
        sunLight.shadowCameraNear = -20;
        sunLight.shadowCameraFar = 60;
        sunLight.shadowCameraLeft = -24;
        sunLight.shadowCameraRight = 24;
        sunLight.shadowCameraTop = 24;
        sunLight.shadowCameraBottom = -24;
        sunLight.shadowDarkness = 0.3;
        sunLight.shadowMapWidth = 1024;
        sunLight.shadowMapHeight = 1024;
        scene.add(sunLight);
        return;
      }

      SunLight.prototype.update = function(camera, delta) {
        this.sunLight.target.position.copy(camera.position);
        this.sunLight.position.copy(camera.position).addSelf(this.sunLightPos);
        this.sunLight.updateMatrixWorld();
        this.sunLight.target.updateMatrixWorld();
      };

      return SunLight;

    })();
    Dust = (function() {
      var fragmentShader, varying, vertexShader;

      varying = "varying vec4 vColor;\nvarying mat2 vRotation;\n";

      vertexShader = varying + "uniform float fScale;\nattribute vec4 aColor;\nattribute vec2 aAngSize;\n\nvoid main() {\n  vColor = aColor;\n  float angle = aAngSize.x;\n  vec2 right = vec2(cos(angle), sin(angle));\n  vRotation = mat2(right.x, right.y, -right.y, right.x);\n  float size = aAngSize.y;\n  //vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n  // Vertices are already in world space.\n  vec4 mvPosition = viewMatrix * vec4( position, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n  gl_PointSize = fScale * size / gl_Position.w;\n}";

      fragmentShader = varying + "uniform sampler2D tMap;\n\nvoid main() {\n  vec2 uv = vec2(gl_PointCoord.x - 0.5, 0.5 - gl_PointCoord.y);\n  vec2 uvRotated = vRotation * uv + vec2(0.5, 0.5);\n  vec4 map = texture2D(tMap, uvRotated);\n  gl_FragColor = vColor * map;\n}";

      function Dust(scene) {
        var attributes, i, mat, params, _i, _ref;
        this.uniforms = {
          fScale: {
            type: 'f',
            value: 1000
          },
          tMap: {
            type: 't',
            value: THREE.ImageUtils.loadTexture("/a/textures/dust.png")
          }
        };
        attributes = {
          aColor: {
            type: 'v4',
            value: []
          },
          aAngSize: {
            type: 'v2',
            value: []
          }
        };
        this.geom = new THREE.Geometry();
        this.aColor = attributes.aColor;
        this.aAngSize = attributes.aAngSize;
        this.other = [];
        this.length = 200;
        for (i = _i = 0, _ref = this.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.geom.vertices.push(new Vec3);
          this.aColor.value.push(new Vec4);
          this.aAngSize.value.push(new Vec2);
          this.other.push({
            angVel: 0,
            linVel: new Vec3
          });
        }
        params = {
          uniforms: this.uniforms,
          attributes: attributes,
          vertexShader: vertexShader,
          fragmentShader: fragmentShader
        };
        params.transparent = true;
        params.depthWrite = false;
        mat = new THREE.ShaderMaterial(params);
        this.particleSystem = new THREE.ParticleSystem(this.geom, mat);
        this.particleSystem.sortParticles = true;
        scene.add(this.particleSystem);
        this.idx = 0;
      }

      Dust.prototype.spawnDust = function(pos, vel) {
        var ang, idx, other, verts;
        verts = this.geom.vertices;
        idx = this.idx;
        verts[idx].copy(pos);
        this.aColor.value[idx].set(0.75 + 0.2 * Math.random(), 0.55 + 0.2 * Math.random(), 0.35 + 0.2 * Math.random(), 1);
        ang = Math.random() * Math.PI * 2;
        this.aAngSize.value[idx].set(ang, 0.2);
        other = this.other[idx];
        other.angVel = Math.random() - 0.5;
        other.linVel.copy(vel);
        other.linVel.z += 0.5;
        return this.idx = (idx + 1) % verts.length;
      };

      Dust.prototype.spawnContrail = function(pos, vel) {
        var ang, idx, intensity, other, verts;
        verts = this.geom.vertices;
        idx = this.idx;
        verts[idx].copy(pos);
        intensity = 1 - Math.random() * 0.05;
        this.aColor.value[idx].set(intensity, intensity, intensity, 0.3);
        ang = Math.random() * Math.PI * 2;
        this.aAngSize.value[idx].set(ang, 0);
        other = this.other[idx];
        other.angVel = 0;
        other.linVel.copy(vel);
        return this.idx = (idx + 1) % verts.length;
      };

      Dust.prototype.update = function(camera, delta) {
        var aAngSize, aColor, idx, length, linVel, linVelScale, other, vertices;
        this.uniforms.fScale.value = 100 / camera.degreesPerPixel;
        this.particleSystem.position.copy(camera.position);
        vertices = this.geom.vertices;
        aColor = this.aColor.value;
        aAngSize = this.aAngSize.value;
        other = this.other;
        linVelScale = 1 / (1 + delta * 1);
        idx = 0;
        length = this.length;
        while (idx < length) {
          linVel = other[idx].linVel;
          linVel.multiplyScalar(linVelScale);
          vertices[idx].addSelf(tmpVec3a.copy(linVel).multiplyScalar(delta));
          aColor[idx].w -= delta * 1;
          aAngSize[idx].x += other[idx].angVel * delta;
          if (aColor[idx].w <= 0) {
            aAngSize[idx].y = 0;
          } else {
            aAngSize[idx].y += delta * 0.5;
          }
          idx++;
        }
        this.geom.verticesNeedUpdate = true;
        this.aColor.needsUpdate = true;
        return this.aAngSize.needsUpdate = true;
      };

      return Dust;

    })();
    keyWeCareAbout = function(event) {
      return event.keyCode <= 255;
    };
    isModifierKey = function(event) {
      return event.ctrlKey || event.altKey || event.metaKey;
    };
    return TriggerClient = (function() {
      function TriggerClient(containerEl, root, options) {
        var loadFunc, prefs, sceneLoader;
        this.containerEl = containerEl;
        this.root = root;
        this.options = options != null ? options : {};
        this.objects = {};
        this.pubsub = new pubsub.PubSub();
        prefs = root.prefs;
        this.renderer = this.createRenderer(prefs);
        if (this.renderer) {
          this.containerEl.appendChild(this.renderer.domElement);
        }
        prefs.on('change:pixeldensity', (function(_this) {
          return function() {
            var _ref;
            if ((_ref = _this.renderer) != null) {
              _ref.devicePixelRatio = prefs.pixeldensity;
            }
            return _this.setSize(_this.width, _this.height);
          };
        })(this));
        this.sceneHUD = new THREE.Scene();
        this.cameraHUD = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, -1);
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 10000000);
        this.camera.idealFov = 75;
        this.camera.degreesPerPixel = 1;
        this.camera.up.set(0, 0, 1);
        this.camera.position.set(0, 0, 500);
        this.scene.add(this.camera);
        this.camControl = null;
        this.scene.fog = new THREE.FogExp2(0xddeeff, 0.0002);
        this.scene.add(new THREE.AmbientLight(0x446680));
        this.scene.add(this.cubeMesh());
        this.add(new SunLight(this.scene));
        this.add(this.dust = new Dust(this.scene));
        this.audio = new clientAudio.Audio();
        if (!prefs.audio) {
          this.audio.mute();
        }
        this.checkpointBuffer = null;
        this.audio.loadBuffer('/a/sounds/checkpoint.ogg', (function(_this) {
          return function(buffer) {
            return _this.checkpointBuffer = buffer;
          };
        })(this));
        this.kachingBuffer = null;
        this.audio.loadBuffer('/a/sounds/kaching.ogg', (function(_this) {
          return function(buffer) {
            return _this.kachingBuffer = buffer;
          };
        })(this));
        this.voiceBuffer = null;
        this.audio.loadBuffer('/a/sounds/voice.ogg', (function(_this) {
          return function(buffer) {
            return _this.voiceBuffer = buffer;
          };
        })(this));
        this.audio.setGain(prefs.volume);
        prefs.on('change:audio', (function(_this) {
          return function(prefs, audio) {
            if (audio) {
              return _this.audio.unmute();
            } else {
              return _this.audio.mute();
            }
          };
        })(this));
        prefs.on('change:volume', (function(_this) {
          return function(prefs, volume) {
            return _this.audio.setGain(volume);
          };
        })(this));
        this.track = new gameTrack.Track(this.root);
        sceneLoader = new THREE.SceneLoader();
        loadFunc = function(url, callback) {
          return sceneLoader.load(url, callback);
        };
        if (this.renderer) {
          this.add(new clientTerrain.RenderTerrain(this.scene, this.track.terrain, this.renderer.context, prefs.terrainhq));
          this.add(new clientScenery.RenderScenery(this.scene, this.track.scenery, loadFunc, this.renderer));
        }
        this.add(new CamTerrainClipping(this.camera, this.track.terrain), 20);
        this.keyDown = [];
      }

      TriggerClient.prototype.onKeyDown = function(event) {
        var _ref;
        if (keyWeCareAbout(event) && !isModifierKey(event)) {
          this.keyDown[event.keyCode] = true;
          this.pubsub.publish('keydown', event);
          if (this.options.blockKeys && ((_ref = event.keyCode) === KEYCODE.UP || _ref === KEYCODE.DOWN || _ref === KEYCODE.LEFT || _ref === KEYCODE.RIGHT || _ref === KEYCODE.SPACE)) {
            event.preventDefault();
          }
        }
      };

      TriggerClient.prototype.onKeyUp = function(event) {
        if (keyWeCareAbout(event)) {
          this.keyDown[event.keyCode] = false;
        }
      };

      TriggerClient.prototype.speak = function(msg) {
        var duration, offset, random, rate, _ref;
        if (!this.voiceBuffer) {
          return;
        }
        _ref = {
          '3': [0, 0.621, 0.03],
          '2': [1.131, 0.531, 0.03],
          '1': [2.153, 0.690, 0.03],
          'go': [3.291, 0.351, 0.03],
          'checkpoint': [4.257, 0.702, 0.03],
          'complete': [5.575, 4.4, 0.03]
        }[msg], offset = _ref[0], duration = _ref[1], random = _ref[2];
        rate = 1 + (Math.random() - 0.3) * random;
        return this.audio.playRange(this.voiceBuffer, offset, duration, 1.5, rate);
      };

      TriggerClient.prototype.playSound = function(name) {
        switch (name) {
          case 'kaching':
            if (this.kachingBuffer) {
              this.audio.playSound(this.kachingBuffer, false, 0.3, 1);
            }
        }
      };

      TriggerClient.prototype.addGame = function(game, options) {
        var objs, onAddVehicle, priority, prog, _i, _len, _ref;
        if (options == null) {
          options = {};
        }
        if (game == null) {
          throw new Error('Added null game');
        }
        objs = [];
        priority = options.isGhost ? 2 : 1;
        objs.push(this.add({
          update: function(cam, delta) {
            return game.update(delta);
          }
        }, priority));
        onAddVehicle = (function(_this) {
          return function(car, progress) {
            var audio, dust, renderCar, renderCheckpoints;
            audio = options.isGhost ? null : _this.audio;
            dust = options.isGhost ? null : _this.dust;
            renderCar = new clientCar.RenderCar(_this.scene, car, audio, dust, options.isGhost);
            objs.push(_this.add(renderCar));
            if (options.isGhost) {
              return;
            }
            objs.push(_this.add(new RenderDials(_this.sceneHUD, car)));
            objs.push(_this.add(renderCheckpoints = new RenderCheckpointsDrive(_this.scene, _this.root)));
            progress.on('advance', function() {
              var _ref;
              renderCheckpoints.highlightCheckpoint(progress.nextCpIndex);
              if (_this.checkpointBuffer != null) {
                return (_ref = _this.audio) != null ? _ref.playSound(_this.checkpointBuffer, false, 1, 1) : void 0;
              }
            });
            if (car.cfg.isReplay) {
              return;
            }
            objs.push(_this.add(_this.camControl = new CamControl(_this.camera, renderCar)));
            objs.push(_this.add(new RenderCheckpointArrows(_this.camera, progress)));
            objs.push(_this.add(new CarControl(car, _this)));
          };
        })(this);
        _ref = game.progs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          prog = _ref[_i];
          onAddVehicle(prog.vehicle, prog);
        }
        game.on('addvehicle', onAddVehicle);
        game.on('destroy', (function(_this) {
          return function() {
            return _this.destroyObjects(objs);
          };
        })(this));
      };

      TriggerClient.prototype.destroyObjects = function(objs) {
        var k, layer, obj, _i, _len, _ref;
        _ref = this.objects;
        for (k in _ref) {
          layer = _ref[k];
          this.objects[k] = _.without.apply(_, [layer].concat(__slice.call(objs)));
        }
        for (_i = 0, _len = objs.length; _i < _len; _i++) {
          obj = objs[_i];
          if (typeof obj.destroy === "function") {
            obj.destroy();
          }
        }
      };

      TriggerClient.prototype.add = function(obj, priority) {
        var layer, _base;
        if (priority == null) {
          priority = 10;
        }
        layer = (_base = this.objects)[priority] != null ? _base[priority] : _base[priority] = [];
        layer.push(obj);
        return obj;
      };

      TriggerClient.prototype.createRenderer = function(prefs) {
        var e, r;
        try {
          r = new THREE.WebGLRenderer({
            alpha: false,
            antialias: prefs.antialias,
            premultipliedAlpha: false,
            clearColor: 0xffffff
          });
          r.devicePixelRatio = prefs.pixeldensity;
          r.shadowMapEnabled = prefs.shadows;
          r.shadowMapCullFace = THREE.CullFaceBack;
          r.autoClear = false;
          return r;
        } catch (_error) {
          e = _error;
          return console.error(e);
        }
      };

      TriggerClient.prototype.updateCamera = function() {
        var aspect;
        aspect = this.height > 0 ? this.width / this.height : 1;
        this.camera.aspect = aspect;
        this.camera.fov = this.camera.idealFov / Math.max(1, aspect / 1.777);
        if (this.renderer) {
          this.camera.degreesPerPixel = this.camera.fov / (this.height * this.renderer.devicePixelRatio);
        }
        this.camera.updateProjectionMatrix();
        this.cameraHUD.left = -aspect;
        this.cameraHUD.right = aspect;
        return this.cameraHUD.updateProjectionMatrix();
      };

      TriggerClient.prototype.setSize = function(width, height) {
        var _ref;
        this.width = width;
        this.height = height;
        if ((_ref = this.renderer) != null) {
          _ref.setSize(this.width, this.height);
        }
        return this.updateCamera();
      };

      TriggerClient.prototype.addEditorCheckpoints = function(parent) {
        return this.add(this.renderCheckpoints = new RenderCheckpointsEditor(parent, this.root));
      };

      TriggerClient.prototype.debouncedMuteAudio = _.debounce(function(audio) {
        return audio.setGain(0);
      }, 500);

      TriggerClient.prototype.muteAudioIfStopped = function() {
        if (this.audio != null) {
          this.audio.setGain(this.root.prefs.volume);
          return this.debouncedMuteAudio(this.audio);
        }
      };

      TriggerClient.prototype.update = function(delta) {
        var layer, object, priority, _i, _len, _ref;
        _ref = this.objects;
        for (priority in _ref) {
          layer = _ref[priority];
          for (_i = 0, _len = layer.length; _i < _len; _i++) {
            object = layer[_i];
            object.update(this.camera, delta);
          }
        }
        return this.muteAudioIfStopped();
      };

      TriggerClient.prototype.render = function() {
        if (!this.renderer) {
          return;
        }
        this.renderer.clear(false, true);
        this.renderer.render(this.scene, this.camera);
        return this.renderer.render(this.sceneHUD, this.cameraHUD);
      };

      TriggerClient.prototype.cubeMesh = function() {
        var cubeMaterial, cubeMesh, cubeShader, format, part, path, textureCube, urls;
        path = "/a/textures/miramar-z-512/miramar_";
        format = '.jpg';
        urls = (function() {
          var _i, _len, _ref, _results;
          _ref = ['rt', 'lf', 'ft', 'bk', 'up', 'dn'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            part = _ref[_i];
            _results.push(path + part + format);
          }
          return _results;
        })();
        textureCube = THREE.ImageUtils.loadTextureCube(urls);
        cubeShader = THREE.ShaderUtils.lib["cube"];
        cubeShader.uniforms["tCube"].value = textureCube;
        cubeMaterial = new THREE.ShaderMaterial({
          fog: true,
          side: THREE.BackSide,
          uniforms: _.extend(THREE.UniformsLib['fog'], cubeShader.uniforms),
          vertexShader: cubeShader.vertexShader,
          fragmentShader: THREE.ShaderChunk.fog_pars_fragment + "\nuniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\n  gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n  vec3 worldVec = normalize(vWorldPosition);\n  gl_FragColor.rgb = mix(fogColor, gl_FragColor.rgb, smoothstep(0.05, 0.15, worldVec.z));\n}"
        });
        cubeMaterial.transparent = true;
        cubeMesh = new THREE.Mesh(new THREE.CubeGeometry(5000000, 5000000, 5000000), cubeMaterial);
        cubeMesh.geometry.faces.splice(5, 1);
        cubeMesh.flipSided = false;
        cubeMesh.doubleSided = true;
        cubeMesh.position.set(0, 0, 20000);
        cubeMesh.renderDepth = 1000000;
        return cubeMesh;
      };

      TriggerClient.prototype.viewToEye = function(vec) {
        vec.x = (vec.x / this.width) * 2 - 1;
        vec.y = 1 - (vec.y / this.height) * 2;
        return vec;
      };

      TriggerClient.prototype.viewToEyeRel = function(vec) {
        vec.x = (vec.x / this.height) * 2;
        vec.y = -(vec.y / this.height) * 2;
        return vec;
      };

      TriggerClient.prototype.viewRay = function(viewX, viewY) {
        var vec;
        vec = this.viewToEye(new Vec3(viewX, viewY, 0.9));
        projector.unprojectVector(vec, this.camera);
        vec.subSelf(this.camera.position);
        vec.normalize();
        return new THREE.Ray(this.camera.position, vec);
      };

      TriggerClient.prototype.findObject = function(viewX, viewY) {
        return this.intersectRay(this.viewRay(viewX, viewY));
      };

      TriggerClient.prototype.intersectRay = function(ray) {
        var isect;
        isect = [];
        isect = isect.concat(this.track.scenery.intersectRay(ray));
        isect = isect.concat(this.intersectCheckpoints(ray));
        isect = isect.concat(this.intersectTerrain(ray));
        isect = isect.concat(this.intersectStartPosition(ray));
        return [].concat.apply([], isect);
      };

      TriggerClient.prototype.intersectTerrain = function(ray) {
        var contact, count, lambda, nextLambda, step, terrainContact, terrainFunc, zeroCrossing;
        zeroCrossing = function(fn, lower, upper, iterations) {
          var constant, crossing, fnCrossing, fnLower, fnUpper, gradient;
          if (iterations == null) {
            iterations = 4;
          }
          fnLower = fn(lower);
          fnUpper = fn(upper);
          gradient = (fnUpper - fnLower) / (upper - lower);
          constant = fnLower - gradient * lower;
          crossing = -constant / gradient;
          if (iterations <= 1) {
            return crossing;
          }
          fnCrossing = fn(crossing);
          if (fnCrossing < 0) {
            return zeroCrossing(fn, crossing, upper, iterations - 1);
          } else {
            return zeroCrossing(fn, lower, crossing, iterations - 1);
          }
        };
        terrainContact = (function(_this) {
          return function(lambda) {
            var test;
            test = ray.direction.clone().multiplyScalar(lambda);
            test.addSelf(ray.origin);
            return {
              test: test,
              contact: _this.track.terrain.getContact(test)
            };
          };
        })(this);
        terrainFunc = (function(_this) {
          return function(lambda) {
            var tc;
            tc = terrainContact(lambda);
            return tc.contact.surfacePos.z - tc.test.z;
          };
        })(this);
        lambda = 0;
        step = 0.2;
        count = 0;
        while (lambda < 50000) {
          nextLambda = lambda + step;
          if (terrainFunc(nextLambda) > 0) {
            lambda = zeroCrossing(terrainFunc, lambda, nextLambda);
            contact = terrainContact(lambda).contact;
            return [
              {
                type: 'terrain',
                distance: lambda,
                object: {
                  pos: [contact.surfacePos.x, contact.surfacePos.y, contact.surfacePos.z]
                }
              }
            ];
          }
          lambda = nextLambda;
          step *= 1.1;
          count++;
        }
        return [];
      };

      TriggerClient.prototype.intersectStartPosition = function(ray) {
        var hit, pos, startpos, _ref;
        if (((_ref = this.root.track) != null ? _ref.config : void 0) == null) {
          return [];
        }
        startpos = this.root.track.config.course.startposition;
        pos = startpos.pos;
        if (pos == null) {
          return [];
        }
        hit = this.intersectSphere(ray, new Vec3(pos[0], pos[1], pos[2]), 4);
        if (hit) {
          hit.type = 'startpos';
          hit.object = startpos;
          return [hit];
        } else {
          return [];
        }
      };

      TriggerClient.prototype.intersectSphere = function(ray, center, radiusSq) {
        var a, along, b, c, discrim;
        center.subSelf(ray.origin);
        a = 1;
        along = ray.direction.dot(center);
        b = -2 * along;
        c = center.dot(center) - radiusSq;
        discrim = b * b - 4 * a * c;
        if (!(discrim >= 0)) {
          return null;
        }
        return {
          distance: along
        };
      };

      TriggerClient.prototype.intersectCheckpoints = function(ray) {
        var cp, hit, idx, isect, radiusSq, _i, _len, _ref, _ref1;
        if (((_ref = this.root.track) != null ? _ref.config : void 0) == null) {
          return [];
        }
        radiusSq = 16;
        isect = [];
        _ref1 = this.root.track.config.course.checkpoints.models;
        for (idx = _i = 0, _len = _ref1.length; _i < _len; idx = ++_i) {
          cp = _ref1[idx];
          hit = this.intersectSphere(ray, new Vec3(cp.pos[0], cp.pos[1], cp.pos[2]), radiusSq);
          if (hit) {
            hit.type = 'checkpoint';
            hit.object = cp;
            hit.idx = idx;
            isect.push(hit);
          }
        }
        return isect;
      };

      return TriggerClient;

    })();
  });

}).call(this);
