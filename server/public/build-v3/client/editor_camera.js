// Generated by CoffeeScript 1.7.1
(function() {
  define(['THREE', 'util/util'], function(THREE, util) {
    var EditorCameraControl, KEYCODE, TWOPI, Vec3, tmpVec3;
    KEYCODE = util.KEYCODE;
    Vec3 = THREE.Vector3;
    TWOPI = Math.PI * 2;
    tmpVec3 = new Vec3;
    return EditorCameraControl = (function() {
      function EditorCameraControl(camera) {
        this.camera = camera;
        this.pos = camera.position;
        this.ang = camera.rotation;
        this.vel = new Vec3;
        this.velTarget = new Vec3;
        this.angVel = new Vec3;
        this.angVelTarget = new Vec3;
        this.autoTimer = -1;
        this.autoPos = new Vec3;
        this.autoAng = new Vec3;
      }

      EditorCameraControl.prototype.autoTo = function(pos, rot) {
        Vec3.prototype.set.apply(this.autoPos, pos);
        this.autoAng.x = 0.9;
        this.autoAng.z = rot[2] - Math.PI / 2;
        this.autoPos.x -= 20 * Math.cos(rot[2]);
        this.autoPos.y -= 20 * Math.sin(rot[2]);
        this.autoPos.z += 30;
        return this.autoTimer = 0;
      };

      EditorCameraControl.prototype.rotate = function(origin, angX, angZ) {
        var rot;
        rot = new THREE.Matrix4();
        rot.rotateZ(-angZ + this.ang.z + Math.PI);
        rot.rotateX(angX);
        rot.rotateZ(-this.ang.z - Math.PI);
        this.pos.subSelf(origin);
        rot.multiplyVector3(this.pos);
        this.pos.addSelf(origin);
        this.ang.x -= angX;
        this.ang.z -= angZ;
        return this.updateMatrix();
      };

      EditorCameraControl.prototype.translate = function(vec) {
        this.pos.addSelf(vec);
        return this.updateMatrix();
      };

      EditorCameraControl.prototype.updateMatrix = function() {
        return this.camera.updateMatrixWorld();
      };

      EditorCameraControl.prototype.update = function(delta, keyDown, terrainHeight) {
        var SPEED, VISCOSITY, mult;
        SPEED = 30 + 0.8 * Math.max(0, this.pos.z - terrainHeight);
        VISCOSITY = 20;
        this.velTarget.set(0, 0, 0);
        this.angVelTarget.set(0, 0, 0);
        if (keyDown[KEYCODE.SHIFT]) {
          SPEED *= 3;
        }
        if (keyDown[KEYCODE.RIGHT]) {
          this.velTarget.x += SPEED;
        }
        if (keyDown[KEYCODE.LEFT]) {
          this.velTarget.x -= SPEED;
        }
        if (keyDown[KEYCODE.UP]) {
          this.velTarget.y += SPEED;
        }
        if (keyDown[KEYCODE.DOWN]) {
          this.velTarget.y -= SPEED;
        }
        if (this.autoTimer !== -1) {
          this.autoTimer = Math.min(1, this.autoTimer + delta);
          if (this.autoTimer < 1) {
            this.velTarget.sub(this.autoPos, this.pos);
            this.velTarget.multiplyScalar(delta * 10 * this.autoTimer);
            this.pos.addSelf(this.velTarget);
            this.ang.z -= Math.round((this.ang.z - this.autoAng.z) / TWOPI) * TWOPI;
            this.velTarget.sub(this.autoAng, this.ang);
            this.velTarget.multiplyScalar(delta * 10 * this.autoTimer);
            this.ang.addSelf(this.velTarget);
          } else {
            this.pos.copy(this.autoPos);
            this.ang.copy(this.autoAng);
            this.autoTimer = -1;
          }
        } else {
          this.velTarget.set(this.velTarget.x * Math.cos(this.ang.z) - this.velTarget.y * Math.sin(this.ang.z), this.velTarget.x * Math.sin(this.ang.z) + this.velTarget.y * Math.cos(this.ang.z), this.velTarget.z);
          mult = 1 / (1 + delta * VISCOSITY);
          this.vel.x = this.velTarget.x + (this.vel.x - this.velTarget.x) * mult;
          this.vel.y = this.velTarget.y + (this.vel.y - this.velTarget.y) * mult;
          this.vel.z = this.velTarget.z + (this.vel.z - this.velTarget.z) * mult;
          this.angVel.x = this.angVelTarget.x + (this.angVel.x - this.angVelTarget.x) * mult;
          this.angVel.y = this.angVelTarget.y + (this.angVel.y - this.angVelTarget.y) * mult;
          this.angVel.z = this.angVelTarget.z + (this.angVel.z - this.angVelTarget.z) * mult;
          this.pos.addSelf(tmpVec3.copy(this.vel).multiplyScalar(delta));
          this.ang.addSelf(tmpVec3.copy(this.angVel).multiplyScalar(delta));
        }
        return this.ang.x = Math.max(0, Math.min(2, this.ang.x));
      };

      return EditorCameraControl;

    })();
  });

}).call(this);
