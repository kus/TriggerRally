// Generated by CoffeeScript 1.7.1

/*
 * Copyright (C) 2012 jareiko / http://www.jareiko.net/
 */

(function() {
  define(['THREE', 'client/array_geometry', 'util/quiver'], function(THREE, array_geometry, quiver) {
    var RenderScenery;
    return {
      RenderScenery: RenderScenery = (function() {
        function RenderScenery(scene, scenery, loadFunc) {
          var l;
          this.scene = scene;
          this.scenery = scenery;
          this.loadFunc = loadFunc;
          this.fadeSpeed = 2;
          this.layers = (function() {
            var _i, _len, _ref, _results;
            _ref = this.scenery.layers;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              l = _ref[_i];
              _results.push(this.createLayer(l));
            }
            return _results;
          }).call(this);
        }

        RenderScenery.prototype.createLayer = function(src) {
          var meshes, render, tiles;
          meshes = [];
          tiles = Object.create(null);
          render = src.config.render;
          this.loadFunc(render["scene-r54"] || render["scene"], function(result) {
            var geom, mesh, _i, _len, _ref;
            _ref = result.scene.children;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              mesh = _ref[_i];
              geom = new array_geometry.ArrayGeometry();
              geom.addGeometry(mesh.geometry);
              mesh.geometry = geom;
              meshes.push(mesh);
            }
          });
          return {
            src: src,
            tiles: tiles,
            meshes: meshes
          };
        };

        RenderScenery.prototype.createTile = function(layer, tx, ty, skipFadeIn) {
          var entities, entity, material, mergedGeom, mesh, object, renderConfig, tile, _i, _j, _len, _len1, _ref;
          entities = layer.src.getTile(tx, ty);
          if (!entities) {
            return null;
          }
          renderConfig = layer.src.config.render;
          tile = new THREE.Object3D;
          tile.position.x = (tx + 0.5) * layer.src.cache.gridSize;
          tile.position.y = (ty + 0.5) * layer.src.cache.gridSize;
          tile.opacity = skipFadeIn ? 1 : 0;
          if (entities.length > 0) {
            _ref = layer.meshes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              object = _ref[_i];
              mergedGeom = new array_geometry.ArrayGeometry();
              mesh = new THREE.Mesh(object.geometry);
              for (_j = 0, _len1 = entities.length; _j < _len1; _j++) {
                entity = entities[_j];
                mesh.scale.copy(object.scale);
                if (renderConfig.scale != null) {
                  mesh.scale.multiplyScalar(renderConfig.scale);
                }
                mesh.scale.multiplyScalar(entity.scale);
                mesh.position.sub(entity.position, tile.position);
                mesh.rotation.add(object.rotation, entity.rotation);
                mergedGeom.mergeMesh(mesh);
              }
              mergedGeom.updateOffsets();
              material = object.material.clone();
              material.opacity = tile.opacity;
              material.transparent = true;
              mesh = new THREE.Mesh(mergedGeom, material);
              mesh.doubleSided = object.doubleSided;
              mesh.castShadow = object.castShadow;
              mesh.receiveShadow = object.receiveShadow;
              tile.add(mesh);
            }
          }
          return tile;
        };

        RenderScenery.prototype.removeTile = function(layer, key) {
          var mesh, _i, _len, _ref;
          this.scene.remove(layer.tiles[key]);
          _ref = layer.tiles[key];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            mesh = _ref[_i];
            mesh.dispose();
          }
          delete layer.tiles[key];
        };

        RenderScenery.prototype.update = function(camera, delta) {
          var addAll, added, fadeAmount, i, key, keys, layer, mesh, tile, toRemove, tx, txCenter, ty, tyCenter, visibleTiles, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
          added = false;
          addAll = false;
          fadeAmount = this.fadeSpeed * delta;
          _ref = this.scenery.layers;
          for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
            layer = _ref[i];
            (_base = this.layers)[i] || (_base[i] = this.createLayer(layer));
            if (this.layers[i].src === layer) {
              continue;
            }
            keys = (function() {
              var _results;
              _results = [];
              for (key in this.layers[i].tiles) {
                _results.push(key);
              }
              return _results;
            }).call(this);
            for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
              key = keys[_j];
              this.removeTile(this.layers[i], key);
            }
            this.layers[i].src = layer;
            addAll = true;
          }
          _ref1 = this.layers;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            layer = _ref1[_k];
            if (!(layer.meshes.length > 0)) {
              continue;
            }
            visibleTiles = {};
            txCenter = Math.floor(camera.position.x / layer.src.cache.gridSize);
            tyCenter = Math.floor(camera.position.y / layer.src.cache.gridSize);
            for (ty = _l = _ref2 = tyCenter - 3, _ref3 = tyCenter + 3; _ref2 <= _ref3 ? _l <= _ref3 : _l >= _ref3; ty = _ref2 <= _ref3 ? ++_l : --_l) {
              for (tx = _m = _ref4 = txCenter - 3, _ref5 = txCenter + 3; _ref4 <= _ref5 ? _m <= _ref5 : _m >= _ref5; tx = _ref4 <= _ref5 ? ++_m : --_m) {
                key = tx + ',' + ty;
                visibleTiles[key] = true;
                tile = layer.tiles[key];
                if (!tile && (addAll || !added)) {
                  tile = this.createTile(layer, tx, ty, addAll);
                  added = true;
                  if (tile) {
                    layer.tiles[key] = tile;
                    this.scene.add(tile);
                  }
                }
                if (tile && tile.opacity < 1) {
                  tile.opacity = Math.min(1, tile.opacity + fadeAmount);
                  _ref6 = tile.children;
                  for (_n = 0, _len3 = _ref6.length; _n < _len3; _n++) {
                    mesh = _ref6[_n];
                    mesh.material.opacity = tile.opacity;
                  }
                }
              }
            }
            toRemove = (function() {
              var _results;
              _results = [];
              for (key in layer.tiles) {
                if (!visibleTiles[key]) {
                  _results.push(key);
                }
              }
              return _results;
            })();
            for (_o = 0, _len4 = toRemove.length; _o < _len4; _o++) {
              key = toRemove[_o];
              tile = layer.tiles[key];
              tile.opacity -= fadeAmount;
              if (tile.opacity > 0) {
                _ref7 = tile.children;
                for (_p = 0, _len5 = _ref7.length; _p < _len5; _p++) {
                  mesh = _ref7[_p];
                  mesh.material.opacity = tile.opacity;
                }
              } else {
                this.removeTile(layer, key);
              }
            }
          }
        };

        return RenderScenery;

      })()
    };
  });

}).call(this);
